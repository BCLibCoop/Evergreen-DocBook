<?xml version='1.0' encoding='UTF-8'?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
	    xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:id="migratingdata" >
	<info>		
	<title>Migrating Data</title>
		<abstract>
			<para>Migrating data into Evergreen can be one of the most daunting tasks for an administrator. This chapter will explain some procedures to help to migrate 
			bibliographic records, copies and patrons into the Evergreen system. This chapter requires advanced ILS Administration experience, knowledge of Evergreen data structures, 
			as well as knowledge of how to export data from your current system or access to data export files from your current system.</para>
        	</abstract>
	</info>    
	<section xml:id="migratingbibrecords">
		<title>Migrating Bibliographic Records</title>
		<indexterm><primary>migrating</primary><secondary>importing bibliographic records</secondary></indexterm>
		<para>
		One of the most important and challenging  tasks is migrating your bibliographic records to a new system. The procedure may be different depending on the system from which you 
		are migrating  and the content of the marc records exported from the existing system. The proecedures in this section deal with the process once the data from the existing system 
		is exporterd into marc records. It does not cover exporting data from your existing non-Evergreen system.</para>
		<para>Several tools for importing bibliographic records into Evergreen can be found in the Evergreen installation folder 
		(<filename class="directory">/home/opensrf/Evergreen-ILS-1.6.1.2/Open-ILS/src/extras/import/</filename> ) and are also available from the Evergreen repository 
		(<link xl:href="http://svn.open-ils.org/trac/ILS/browser/branches/rel_1_6_1/Open-ILS/src/extras/import" xl:title="import scripts - Evergreen repository">
		http://svn.open-ils.org/trac/ILS/browser/branches/rel_1_6_1/Open-ILS/src/extras/import</link>).</para> 
		<simplesect>
			<title>Converting MARC records to Evergreen BRE JSON format</title>
			<indexterm><primary>BRE JSON</primary></indexterm>
			<para>If you are starting with MARC records from your existing system or another source, use the marc2bre.pl script to create the JSON representation of a bibliographic 
			record entry (hence bre) in Evergreen. <filename>marc2bre.pl</filename> can perform the following functions:</para>
     			<itemizedlist> 
				<listitem><para>Converts <systemitem>MARC-8</systemitem> encoded records to <systemitem>UTF-8</systemitem> encoding</para></listitem>
      				<listitem><para>Converts <systemitem>MARC21</systemitem> to <systemitem>MARCXML21</systemitem></para></listitem>
     				<listitem><para>Select the unique record number field (common choices are '035' or '001'; check your records as you might be surprised how a supposedly unique field 
				actually has duplicates, though marc2bre.pl will select a unique identifier for subsequent duplicates)</para></listitem>
     				<listitem><para>Extracts certain pertinent fields indexing and display purposes (along with the complete MARCXML21 record)</para></listitem>
     				<listitem><para>Sets the ID number of the first record from this batch to be imported into the biblio.record_entry table (hint - run the following 
				<systemitem>SQL</systemitem> to determine what this number should be to avoid conflicts:</para>
<screen>
<userinput>psql -U postgres evergreen</userinput>
<userinput> # SELECT MAX(id)+1 FROM biblio.record_entry;</userinput>
</screen>
			</listitem>
            		<listitem>
				<para>If you are processing multiple sets of MARC records with <command>marc2bre.pl</command>before loading the records into the database, you will need to keep track 
				of the starting ID number for each subsequent batch of records that you are importing. For example, if you are processing three files of MARC records with 10000 
				records each into a clean database, you would use <option>–startid 1</option>, <option>–startid 10001</option>, and <option>–startid 20001</option> 
				parameters for each respective file.</para>
			</listitem>
      			<listitem>
				<para>Ignore <quote>trash</quote> fields that you do not want to retain in Evergreen</para>
			</listitem>
			<listitem>
				<para>If you use <filename>marc2bre.pl</filename> to convert your MARC records from the <systemitem>MARC-8</systemitem> encoding to the UTF-8 encoding, it relies
				 on the <systemitem>MARC::Charset Perl</systemitem> module to complete the conversion. When importing a large set of items, you can speed up the process by using a 
				utility like <systemitem>marc4j</systemitem> or <systemitem>marcdumper</systemitem> to convert the records 
				to <systemitem>MARC21XML</systemitem> and <systemitem>UTF-8</systemitem> before running them through <command>marc2bre.pl</command> with the 
				<option>–marctype=XML</option> flag to tell <command>marc2bre.pl</command> that the records are already in <systemitem>MARC21XML</systemitem> format with 
				the <systemitem>UTF-8 </systemitem>encoding. If you take this approach, due to a current limitation of <systemitem>MARC::File::XML</systemitem> you have to do a 
				horrible thing and ensure that there are no namespace prefixes in front of the element names. <filename>marc2bre.pl</filename> cannot parse the following 
				example:</para>

<programlisting language="xml">
<![CDATA[

<?xml version="1.0" encoding="UTF-8" ?>
<marc:collection xmlns:marc="http://www.loc.gov/MARC21/slim" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://www.loc.gov/MARC/slim 
http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd">
  <marc:record>
    <marc:leader>00677nam a2200193 a 4500</marc:leader>
    <marc:controlfield tag="001">H01-0000844</marc:controlfield>
    <marc:controlfield tag="007">t </marc:controlfield>
    <marc:controlfield tag="008">060420s1950    xx            000 u fre d</marc:controlfield>
    <marc:datafield tag="040" ind1=" " ind2=" ">
      <marc:subfield code="a">CaOHCU</marc:subfield>
      <marc:subfield code="b">fre</marc:subfield>
    </marc:datafield>
...
]]>;
</programlisting>
			
			<para>But marc2bre.pl can parse the same example with the namespace prefixes removed:</para>
<programlisting language="xml">
<![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<collection xmlns:marc="http://www.loc.gov/MARC21/slim" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://www.loc.gov/MARC/slim 
http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd">
  <record>
    <leader>00677nam a2200193 a 4500</leader>
    <controlfield tag="001">H01-0000844</controlfield>
    <controlfield tag="007">t </controlfield>
    <controlfield tag="008">060420s1950    xx            000 u fre d</controlfield>
    <datafield tag="040" ind1=" " ind2=" ">
      <subfield code="a">CaOHCU</subfield>
      <subfield code="b">fre</subfield>
    </datafield>
...
]]>;
</programlisting>
				</listitem>
			</itemizedlist>
		</simplesect>
		<simplesect>
			<title>Converting Records for Import into PostgreSQL</title>
			<indexterm><primary>migrating</primary><secondary>import into PostgreSQL</secondary></indexterm>
			<para>Once you have your records in Evergreen's <systemitem>BRE JSON</systemitem> format, you then need to use <command>direct_ingest.pl</command> to convert the records 
			into the generic ingest <systemitem>JSON</systemitem> format for Open-ILS. 
			This step uses the <systemitem>open-ils.ingest</systemitem> application to extract the data that will be indexed in the database. </para>
			<para>Once you have your records in Open-ILS <systemitem>JSON</systemitem> ingest format, you then need to use <command>pg_loader.pl</command> to convert these records into a 
			set of <systemitem>SQL</systemitem> statements that you can use to 
			load the records into PostgreSQL. The <option>–order</option> and <option>–autoprimary</option> command line options (bre, mrd, mfr, etc) map to class IDs defined in 
			<filename>/openils/conf/fm_IDL.xml</filename>.</para>
		</simplesect>		
		<simplesect>
			<title>Adding Metarecords to the Database</title>
			<indexterm><primary>migrating</primary><secondary>adding metarecords</secondary></indexterm>
			<para>One you have loaded the records into PostgreSQL, you can create metarecord entries in the <link linkend="metabib.table.metarecord">metabib.metarecord</link> table by 				running the following <systemitem>SQL</systemitem>:</para>
<screen>
<userinput>psql evergreen</userinput>
<userinput># \i /home/opensrf/Evergreen-ILS-1.6*/src/extras/import/quick_metarecord_map.sql</userinput>
</screen>
			<para>Metarecords are required to place holds on items, among other actions.</para>
		</simplesect>	
	</section>
	<section xml:id="migratingbibrecordcopies">
		<title>Adding Copies to Bibliographic Records</title>
		<indexterm><primary>migrating</primary><secondary>adding copies</secondary></indexterm>	
		<para>Once you've loaded the bibliographic records in Evergreen, you can search and view the records in the staff client, but they will not be visible in the catalogue. By 
		default, bibliographic records will not be visible in the catalogue until you add a copy representing a physical manifestation of that resource. You can add a copy manually through 
		the staff client via the Holdings maintenance screen, but if you're bulk-importing MARC records you probably want to bulk load the associated copies, call numbers, and barcodes as 
		well.</para>
		<simplesect>
			<title>Importing volumes and copies from <systemitem>MARC21XML</systemitem> holdings</title>
			<indexterm><primary>migrating</primary><secondary>importing volumes</secondary></indexterm>	
			<para>There is currently no simple method for importing holdings based on the contents of the MARC holdings field (852, as specified by 
			<link xml:href="http://www.loc.gov/marc/holdings/">http://www.loc.gov/marc/holdings/</link>). 
			However, a more or less automated method could be built that performs the following steps:</para>
			<procedure>
				<step><para>Create a tab-delimited file that contains your holdings information</para>
				<itemizedlist>
					<listitem>Required fields: bibliographic ID, barcode, and call number</listitem>		
					<listitem>Optional fields: shelving location (text) – see  the <link linkend="asset.table.copy">asset.copy table</link> for 
					possible fields to include</listitem>
				</itemizedlist>		
				</step>
				<step><para>Create a staging table that matches the contents of your tab-delimited file.</para>
				</step>
				<step><para>Insert the contents of your tab-delimited file into the table.</para>
				</step>
				<step><para>Generate <systemitem>SQL</systemitem> scripts for item import to match the staging table that you created.</para>
				</step>
				<step><para>Run the <systemitem>SQL</systemitem> scripts to create the holdings in Evergreen.</para>
				</step>
			</procedure>
			<para>If an ILS has the concept of <quote>item categories</quote>, these may be mapped to Evergreen via statistical categories in the 
			<link linkend="asset.table.stat-cat">asset.stat_cat table</link> . Note that statistical categories cannot be used as search filters; individual branches can define 
			their own statistical categories; and define their own statistical category entries for individual items - best use case for statistical categories is probably for gifts.</para>
			<para>In 2009, Conifer placed their <link xl:href="http://svn.open-ils.org/trac/ILS-Contrib/browser/conifer/branches/rel_1_6_1/tools/migration-scripts"  
			xl:title="Conifer migration tools">migration tools</link> 
			in the <link xl:href="http://svn.open-ils.org/trac/ILS-Contrib/browser/conifer" xl:title="Conifer ILS-Contrib SVN repository">Conifer ILS-Contrib SVN repository</link>, which might be useful samples augmenting the 
			basic staging table import approach.</para>
			<para>In 2010, Equinox contributed a set of <link xl:href="http://git.esilibrary.com/?p=migration-tools.git;a=summary"  xl:title="Equinox migration utilities">migration utilities</link></para>
		</simplesect>
	</section>
	<section xml:id="migratingpatrons">
		<title>Migrating Patron Data</title>
		<indexterm><primary>migrating</primary><secondary>importing patrons</secondary></indexterm>
		<para>
		This section will explain the task of migrating your patron data from comma delimited files<indexterm><primary>comma delimited files</primary></indexterm> into Evergreen. 
		It does not deal with the process of exporting from the non-Evergreen 
		system since this process may vary depending on where you are extracting your patron records. Patron could come from an ILS or it could come from a student database in the case of 
		academic records.  		
		</para>
		<para>When importing records into Evergreen you will need to populate 3 tables in your Evergreen database:</para>
		<itemizedlist>
			<listitem><link linkend="actor.table.usr">actor.usr</link> - The main table for user data</listitem>
			<listitem><link linkend="actor.table.card">actor.card</link> - Stores the barcode for users; Users can have more than 1 card but only 1 can be active at a given time;</listitem>
			<listitem><link linkend="actor.table.usr-address">actor.usr_address</link> - Used for storing address information; A user can have more than one address.</listitem>
		</itemizedlist>
		<para>Before following the procedures below to import patron data into Evergreen, it is a good idea to examine the fields in these tables in order to decide on a strategy 
		for data to include 
		in your import. It is important to understand the data types and constraints on each field.</para>
		<procedure>
			<step>
				<para>Export the patron data from your existing ILS or from another source into a comma delimited file. The comma delimited file used for importing
				 the records should use Unicode (UTF8) <indexterm><primary>Unicode</primary></indexterm> character encoding.</para>
			</step>
			<step>
				<para>Create a staging table.<indexterm><primary>staging table</primary></indexterm>  A staging table will allow you to tweak the data before importing. 
				Here is an example sql statement:</para>
				<indexterm><primary>sql</primary></indexterm> 
<programlisting language="sql">
CREATE TABLE students (
	 student_id int, barcode text, last_name text, first_name text, program_number text, 
	program_name text, email text, address_type text, street1 text, street2 text, 
	city text, province text, country text, postal_code text, phone text, profile int, 
	ident_type int, home_ou int, claims_returned_count int DEFAULT 0, usrname text, 
	net_access_level int DEFAULT 2, password text
); 
</programlisting>
				<para>Note the <varname>DEFAULT</varname> variables. These allow you to set default for your library or to populate required fields if you data allows 
				<systemitem>NULL</systemitem> values where fields are required in Evergreen.</para>
			</step>
			<step>
				<para>Formatting of some fields to fit Evergreen filed formatting may be required. Here is an example of sql to adjust phone numbers in the staging 
				table to fit the evergreen field:</para>
<programlisting language="sql">
UPDATE students phone = replace(replace(replace(rpad(substring(phone from 1 for 9), 10, '-') || 
substring(phone from 10), '(', ''), ')', ''), ' ', '-');
</programlisting>
				<para>Data <quote>massaging</quote> may be required to fit formats used in Evergreen.</para>
			</step>
			<step>
				<para>Insert records from the staging table into the <link linkend="actor.table.usr">actor.usr</link> Evergreen table:</para>
<programlisting language="sql">
 INSERT INTO actor.usr (
	profile, usrname, email, passwd, ident_type, ident_value, first_given_name, 
	family_name, day_phone, home_ou, claims_returned_count, net_access_level) 
	SELECT profile, students.usrname, email, student_id, ident_type, student_id, 
	first_name, last_name, phone, home_ou, claims_returned_count, net_access_level 
	FROM students;
</programlisting>			
			</step>
			<step>
				<para>insert records into <link linkend="actor.table.card">actor.card</link> from <link linkend="actor.table.usr">actor.usr</link>.</para>
<programlisting language="sql">
INSERT INTO actor.card (usr, barcode) 
	SELECT actor.usr.id, students.barcode 
	FROM students 
		INNER JOIN actor.usr 
			ON students.usrname = actor.usr.usrname;
</programlisting>		
				<para>This assumes a one to one card patron relationship. If your patron data import has multiple cards assigned to one patron more complex import scripts may be required 					which look for inactive or active flags.</para>	
			</step>
			<step>
				<para>Update actor.usr.card field with actor.card.id to associate active card with the user:</para>
<programlisting language="sql">
UPDATE actor.usr 
	SET card = actor.card.id 
	FROM actor.card 
	WHERE actor.card.usr = actor.usr.id;
</programlisting>			
			</step>
			<step>
				<para>Insert records into <link linkend="actor.table.usr-address">actor.usr_address</link> to add address information for users:</para>
<programlisting language="sql">
INSERT INTO actor.usr_address (usr, street1, street2, city, state, country, post_code) 
	SELECT actor.usr.id, students.street1, students.street2, students.city, students.province, 
	students.country, students.postal_code 
	FROM students 
	INNER JOIN actor.usr ON students.usrname = actor.usr.usrname;
</programlisting>			
			</step>
			<step>
				<para>update <link linkend="actor.table.usr-address">actor.usr.address</link> with address id from address table.</para>
<programlisting language="sql">
UPDATE actor.usr 
	SET mailing_address = actor.usr_address.id, billing_address = actor.usr_address.id 
	FROM actor.usr_address 
	WHERE actor.usr.id = actor.usr_address.usr;
</programlisting>	
			<para>This assumes 1 address per patron. More complex scenarios may require more sophisticated SQL.</para>		
			</step>
		</procedure>
		<simplesect>
			<title>Creating an sql Script for Importing Patrons</title>
			<para>The procedure for importing patron can be automated with the help of an sql script. Follow these steps to create an import script:</para>
		
			<procedure>
				<step>
					<para>Create an new file and name it <filename>import.sql</filename></para>

				</step>

				<step>
					<para>Edit the file to look similar to this:</para>
<programlisting>
BEGIN;

-- Create staging table.
CREATE TABLE students (
	student_id int, barcode text, last_name text, first_name text, program_number text, 
	program_name text, email text, address_type text, street1 text, street2 text, 
	city text, province text, country text, postal_code text, phone text, profile int, 
	ident_type int, home_ou int, claims_returned_count int DEFAULT 0, usrname text, 
	net_access_level int DEFAULT 2, password text
); 


--Insert records from the staging table into the actor.usr table.
INSERT INTO actor.usr (
	profile, usrname, email, passwd, ident_type, ident_value, first_given_name, family_name, 
	day_phone, home_ou, claims_returned_count, net_access_level) 
	SELECT profile, students.usrname, email, student_id, ident_type, student_id, first_name, 
	last_name, phone, home_ou, claims_returned_count, net_access_level FROM students;

--Insert records from the staging table into the actor.usr table.
INSERT INTO actor.card (usr, barcode) 
	SELECT actor.usr.id, students.barcode 
	FROM students 
		INNER JOIN actor.usr 
			ON students.usrname = actor.usr.usrname;

--Update actor.usr.card field with actor.card.id to associate active card with the user:
UPDATE actor.usr 
	SET card = actor.card.id 
	FROM actor.card 
	WHERE actor.card.usr = actor.usr.id;

--INSERT records INTO actor.usr_address from staging table.
INSERT INTO actor.usr_address (usr, street1, street2, city, state, country, post_code) 
	SELECT actor.usr.id, students.street1, students.street2, students.city, students.province, 
	students.country, students.postal_code 
	FROM students 
	INNER JOIN actor.usr ON students.usrname = actor.usr.usrname;


--Update actor.usr mailing address with id from actor.usr_address table.:
UPDATE actor.usr 
	SET mailing_address = actor.usr_address.id, billing_address = actor.usr_address.id 
	FROM actor.usr_address 
	WHERE actor.usr.id = actor.usr_address.usr;

COMMIT;
</programlisting>
					<para>Placing the sql statements between <code>BEGIN;</code> and <code>COMMIT;</code> creates a transaction block so that if any sql statements fail, the 
					entire process is canceled and the database is rolled back to its original state. Lines beginning with <code>--</code> are comments to let you you what 
					each sql statement is doing and are not processed.</para> 
				</step>
			</procedure>
		</simplesect>
		<simplesect>
			<title>Batch Updating Patron Data</title>
			<indexterm><primary>migrating</primary><secondary>batch updating patrons</secondary></indexterm>
			<para>For academic libraries, doing batch updates to add new patrons to the Evergreen database is a critical task. The above procedures and 
			import script can be easily adapted to create an update script for importing new patrons from external databases. If the data import file contains only new patrons, then, 
			the above procedures will work well to insert those patrons. However, if the data load contains all patrons, a second staging table and a procedure to remove existing 				patrons from that second staging table may be required before importing the new patrons. Moreover, additional steps to update address information and perhaps delete 
			inactive patrons may also be desired depending on the requirements of the institution.</para>
			<para>After developing the scripts to import and update patrons have been created, another important task for library staff is to develop an import strategy and schedule 
			which suits the needs of the library. This could be determined by registration dates of your institution in the case of academic libraries. It is important to balance 
			the convenience of patron loads and the cost of processing these loads vs staff adding patrons manually.</para>   
	       </simplesect> 
	</section>
	<section xml:id="electronicresourcesvisible">	
		<title>Making Electronic Resources Visible in the Catalogue</title>
		<indexterm><primary>migrating</primary><secondary>importing bibliographic records</secondary><tertiary>electronic resources </tertiary></indexterm>
		<para>For electronic resources that should be visible in the catalogue without any copies, you must set the source column value in the record.biblio_entry row for the respective 
		bibliographic record to a value that matches the corresponding ID of the <link linkend="config.table.bib-source">config.bib_source</link> where the transcendant value is 
		<emphasis>TRUE</emphasis>. Here's a practical example:</para>
		<procedure>
		  	 <step>
				<para>Connect to your Evergreen database with <command>psql</command> (substitute username / database name as required):</para>
<screen>
<userinput>psql -U postgres evergreen</userinput>
</screen>
			</step>
		 	 <step>
				<para>Add a source for your electronic resources:</para>
<screen>
<userinput>
# INSERT INTO config.bib_source(quality, source, transcendant) 
	VALUES (50, 'Institutional repository', TRUE);</userinput>
</screen>
			</step>
		 	 <step>
				<para>Find the ID that was generated for your new source:</para>
<screen>
<userinput># SELECT ID FROM config.bib_source WHERE source = 'Institutional repository';</userinput>
</screen>
			</step>
		 	 <step>
				<para>Update the source column for your bibliographic record for the electronic resource (for the sake of the example, let's assume that the ID returned from the new 
				source was 4, and that we know that the bib record with ID 75 is an electronic resource from your institutional repository):</para>
<screen>
<userinput># UPDATE biblio.record_entry SET source = 4 where biblio.record_entry.id=75;</userinput>
</screen>
			</step>
		</procedure>
	</section>
	<section xml:id="emptydatabase">
		<title>Restoring your Evergreen Database to an Empty State</title>
		<para>If you've done a test import of records and you want to quickly get Evergreen back to a pristine state, you can create a clean Evergreen database schema by performing the 
		following:</para>
		<procedure>
			<step> 
<screen>
<userinput>cd ILS/Open-ILS/src/sql/Pg/</userinput>
</screen>
			</step>
			 <step> 
				 <para>Rebuild the database schema:</para>
<screen>
<userinput>./build-db.sh [db-hostname> [db-port] [db-name] [db-user] [db-password] [db-version]</userinput>
</screen>
				<caution><para>This will remove all of your data from the database and restore the default values.</para></caution> 		
			</step>
		</procedure>
	</section>
</chapter>
