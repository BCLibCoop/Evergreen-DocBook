<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="developer_workshop" xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="EN"
    xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink">

<chapterinfo>
    <title>Evergreen development</title>
    <date>February 2010</date>
    <author>
        <firstname>Dan</firstname>
        <surname>Scott</surname>
        <email>dscott@laurentian.ca</email>
    </author>
    <authorinitials>DS</authorinitials>
<revhistory><revision><revnumber>1.0</revnumber><date>February 2010</date><authorinitials>DS</authorinitials></revision></revhistory>
</chapterinfo>
<section id="_part_1_opensrf_applications">
<title>Part 1: OpenSRF applications</title>
<simpara>OpenSRF, pronounced "Open Surf", is the Open <emphasis role="strong">S</emphasis>ervice <emphasis role="strong">R</emphasis>equest
<emphasis role="strong">F</emphasis>ramework. It was designed as an architecture on which one could
easily build scalable applications.</simpara>
<section id="_introduction_to_opensrf">
<title>Introduction to OpenSRF</title>
<simpara>The framework is built on JSON-over-XMPP. XML can be used, but JSON
is much less verbose. XMPP is a standard messaging protocol that
has been used as the backbone of low-latency, high-volume
applications including instant messaging and Google Wave.</simpara>
<simpara>OpenSRF offers scalability via its clustering architecture; a service
that is a bottleneck can be moved onto its own server; or multiple
instances of the service can be run on many servers. Services can
themselves be clients of other services.</simpara>
<simpara>OpenSRF services listen at an XMPP address such as
"opensrf@private.localhost/open-ils.fielder_drone_at_localhost_7652".
The initial request from an OpenSRF client is directed to the
OpenSRF router, which determines whether the requested service is
accessible to the client (based on the public versus private domains),
and then connects the client to the service for any subsequent
communication that is required.</simpara>
<simpara>To significantly improve the speed at which request services can
respond to common requests, OpenSRF has integrated support for the
caching via the <literal>memcached</literal> daemon. For example, the contents of the
configuration files are cached by the <literal>opensrf.settings</literal> service when
that service starts, so that rather than having to parse the XML file
every time a service checks a configuration setting, the value can be
retrieved with much less overhead directly from the cache.</simpara>
<note><simpara>if you change a setting in one of those configuration files, you
must restart the <literal>opensrf.settings</literal> service to update its data. You must
then restart any of the services that make use of that setting to make
the change take effect.</simpara></note>
<simpara>Supports Perl, C, and Python as services and clients, and Java as a
client. JavaScript can access services via HTTP translator and
gateway. JSON library converts messages to/from native structures for
ease of development.</simpara>
</section>
<section id="_configuring_opensrf">
<title>Configuring OpenSRF</title>
<simpara>Walk through the configuration files, explaining <emphasis>why</emphasis> we put the values
into the files that we do:</simpara>
<itemizedlist>
<listitem>
<simpara>
opensrf_core.xml
</simpara>
<itemizedlist>
<listitem>
<simpara>
Distinguish between public and private services for security of Web-based applications.
</simpara>
</listitem>
<listitem>
<simpara>
Deprecated HTTP gateway versus OpenSRF-over-HTTP
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
opensrf.xml
</simpara>
</listitem>
</itemizedlist>
<tip><simpara>In a clustered OpenSRF instance, these files are normally hosted on
a network share so that each member of the cluster can read them.</simpara></tip>
</section>
<section id="_starting_opensrf_services">
<title>Starting OpenSRF services</title>
<note><simpara>I won&#8217;t go through this during a live session. Perhaps I can cut this
out entirely&#8230;</simpara></note>
<simpara>Issue the following commands as the <literal>opensrf</literal> user. If you are running OpenSRF
on a single-server machine, you can use the <literal>-l</literal> flag to force the hostname
to be treated as <literal>localhost</literal>.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Start the OpenSRF router:
</simpara>
<screen>osrf_ctl.sh -a start_router</screen>
<important><simpara>The router must only run on a single machine in a given brick.</simpara></important>
</listitem>
<listitem>
<simpara>
Start all OpenSRF Perl services defined for this host:
</simpara>
<screen>osrf_ctl.sh -a start_perl</screen>
<tip><simpara>You can start an individual Perl service using:</simpara></tip>
<screen>opensrf-perl.pl -s &lt;service-name&gt; -a start -p &lt;PID-directory&gt;</screen>
</listitem>
<listitem>
<simpara>
Start all OpenSRF C services defined for this host:
</simpara>
<screen>osrf_ctl.sh -a start_c</screen>
</listitem>
</orderedlist>
</section>
<section id="_stopping_opensrf_services">
<title>Stopping OpenSRF services</title>
<simpara>Issue the following commands as the <literal>opensrf</literal> user. If you are running OpenSRF
on a single-server machine, you can use the <literal>-l</literal> flag to force the hostname
to be treated as <literal>localhost</literal>.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Stop the OpenSRF router:
</simpara>
<screen>osrf_ctl.sh -a stop_router</screen>
</listitem>
<listitem>
<simpara>
Stop all OpenSRF Perl services defined for this host:
</simpara>
<screen>osrf_ctl.sh -a stop_perl</screen>
<tip><simpara>You can stop an individual Perl service using:</simpara></tip>
<screen>opensrf-perl.pl -s &lt;service-name&gt; -a stop -p &lt;PID-directory&gt;</screen>
</listitem>
<listitem>
<simpara>
Stop all OpenSRF C services defined for this host:
</simpara>
<screen>osrf_ctl.sh -a stop_c</screen>
</listitem>
</orderedlist>
<important><simpara>PID files for OpenSRF services are stored and looked up
in <literal>/openils/var/run</literal> by default with <literal>osrf_ctl.sh</literal>, and in
<literal>/tmp/</literal> with <literal>opensrf-perl.pl</literal>.  For a clustered server instance
of Evergreen, you must store the PIDs on a directory that is local
to each server, or else one of your cluster servers may try
killing processes on itself that actually have PIDs on other servers.</simpara></important>
</section>
</section>
<section id="_examining_sample_code">
<title>Examining sample code</title>
<simpara>Show internal documentation for methods. Do some stupid srfsh tricks
(<literal>introspect</literal> for one) and show <literal>docgen.xsl</literal> in action.</simpara>
<section id="_srfsh_stupid_tricks">
<title>SRFSH stupid tricks</title>
<screen>srfsh# introspect open-ils.auth
... returns documentation for all methods registered for open-ils.auth

srfsh# introspect open-ils.auth "open-ils.auth.authenticate"
... returns documentation for all methods with names beginning with
    "open-ils.auth.authenticate" registered for open-ils.auth

srfsh# open open-ils.cstore
... begins a stateful connection with open-ils.cstore
srfsh# request open-ils.cstore open-ils.cstore.transaction.begin
... begins a transaction
srfsh# request open-ils.cstore open-ils.cstore.direct.config.language_map.delete \
   {"code": {"like":"a%"}}
... deletes all of the entries from config.language_map that have a
... code beginning with "e"
srfsh# request open-ils.cstore open-ils.cstore.transaction.rollback
... rolls back the transaction
srfsh# close open-ils.cstore
... closes the stateful connection with open-ils.cstore</screen>
</section>
<section id="_perl">
<title>Perl</title>
<section id="_services">
<title>Services</title>
<simpara>See <literal>OpenSRF/src/perl/lib/OpenSRF/UnixServer.pm</literal> to understand how the
optional methods for initializing and cleaning up OpenSRF services
are invoked:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>initialize()</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>child_init()</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>child_exit()</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>Services are implemented as Perl functions. Each service needs to be registered with:</simpara>
<programlisting language="perl" linenumbering="unnumbered">__PACKAGE__-&gt;register_method(
  method =&gt; 'method name',                      # <co id="CO1-1"/>
  api_name =&gt; 'API name',                       # <co id="CO1-2"/>
  api_level =&gt; 1,                               # <co id="CO1-3"/>
  argc =&gt; # of args,                            # <co id="CO1-4"/>
  signature =&gt; {                                # <co id="CO1-5"/>
    desc =&gt; “Description”,
    params =&gt; [
      {
        name =&gt; 'parameter name',
        desc =&gt; 'parameter description',
        type =&gt; '(array|hash|number|string)'
      }
    ],
    return =&gt; {
      desc =&gt; 'Description of return value',
      type =&gt; '(array|hash|number|string)'
    }
  }
);</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<simpara>
The method name is the name of the Perl method that is called when a
client invokes the corresponding OpenSRF method.
</simpara>
</callout>
<callout arearefs="CO1-2">
<simpara>
The API name is the OpenSRF method name. By convention, each API
uses the OpenSRF service name for its root, and then appends one or more
levels of names to the OpenSRF service name, depending on the complexity
of the service and the number of methods exposed by a given service.
</simpara>
</callout>
<callout arearefs="CO1-3">
<simpara>
The API level is always <literal>1</literal>.
</simpara>
</callout>
<callout arearefs="CO1-4">
<simpara>
The number of arguments that can be passed to the OpenSRF method is
primarily for guidance purposes.
</simpara>
</callout>
<callout arearefs="CO1-5">
<simpara>
The signature is consumed by the various utilities (srfsh, docgen.xsl)
that generate documentation about the OpenSRF service.
</simpara>
</callout>
</calloutlist>
<simpara>Note that arguments are converted between native data structures and JSON
for us for free.</simpara>
</section>
<section id="_client_cheat_sheet">
<title>Client cheat sheet</title>
<simpara>This is the simplest possible OpenSRF client written in Perl:</simpara>
<programlisting language="perl" linenumbering="unnumbered"></programlisting>
<calloutlist>
<callout arearefs="">
<simpara>
The <literal>OpenSRF::System</literal> module gives our program access to the core OpenSRF
client functionality.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The <literal>bootstrap_client()</literal> method reads the <literal>opensrf_core.xml</literal> file and sets
up communication with the OpenSRF router.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The <literal>OpenSRF::Appsession-&gt;create()</literal> instance method asks the router if it
can connect to the named service. If the router determines that the service
is accessible (either the opensrf credentials are on the private domain, which
gives it access to all public and private services; or the service is on a
public domain, which is accessible to both public and private opensrf
credentials), it returns an OpenSRF session with a connection to the named service.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The <literal>OpenSRF::Appsession-&gt;request()</literal> method invokes a method of the
associated service to return a request object.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The method name that you want to invoke is the first argument to <literal>request()</literal>.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The arguments to the method follow the method name.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Invoking the <literal>gather()</literal> method on the returned request object returns a
single result.
</simpara>
<note><simpara>If the service is expected to return multiple results, you should loop
over it with <literal>recv()</literal> instead. But then, that wouldn&#8217;t be the simplest
possible client anymore would it?</simpara></note>
</callout>
<callout arearefs="">
<simpara>
The <literal>OpenSRF::Appsession-&gt;disconnect()</literal> instance method disconnects from
the service, enabling that child to go on and handle other requests.
</simpara>
</callout>
</calloutlist>
</section>
</section>
<section id="_javascript">
<title>JavaScript</title>
<simpara>Historically, JavaScript has had access to OpenSRF methods via the
OpenSRF HTTP gateway Apache module. You can still see this in heavy use
in the OPAC and staff client as of Evergreen 1.6, but the approach has been
deprecated as it has significant performance problems with large responses.
The successor for the OpenSRF gateway is the OpenSRF-over-HTTP translator
Apache module, which supports streaming responses for improved performance
and better support for the broad range of OpenSRF attributes.</simpara>
<section id="_invoking_methods_via_the_http_translator">
<title>Invoking methods via the HTTP Translator</title>
<simpara>The following example demonstrates the basic approach to invoking
OpenSRF methods via JavaScript. It uses just three OpenSRF JavaScript
libraries to simplify calls to the OpenSRF-over-HTTP translator,
which became available to developers as part of the OpenSRF 1.0 /
Evergreen 1.4 releases.</simpara>
<programlisting language="html" linenumbering="unnumbered"></programlisting>
<calloutlist>
<callout arearefs="">
<simpara>
opensrf.js defines most of the objects and methods required for a bare
JavaScript call to the OpenSRF HTTP translator.
</simpara>
</callout>
<callout arearefs="">
<simpara>
opensrf_xhr.js provides cross-browser XMLHttpRequest support for OpenSRF.
</simpara>
</callout>
<callout arearefs="">
<simpara>
JSON_v1.js converts the requests and responses between JavaScript and the
JSON format that the OpenSRF translator expects.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Create a client session that connects to the <literal>open-ils.resolver</literal> service.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Create a request object that identifies the target method and passes the
required method arguments.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Define the function that will be called when the request is sent and
results are returned from the OpenSRF HTTP translator.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Loop over the returned results using the <literal>recv()</literal> method.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The content of each result is accessible via the content() method of
each returned result.
</simpara>
</callout>
<callout arearefs="">
<simpara>
<literal>open-ils.resolver.resolve_holdings</literal> returns a hash of values, so
invoking one of the hash keys (<literal>coverage</literal>) gives us access to that value.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Actually send the request to the method; the function defined by
<literal>req.oncomplete</literal> is invoked as the results are returned.
</simpara>
</callout>
</calloutlist>
</section>
</section>
</section>
<section id="_exercise">
<title>Exercise</title>
<simpara>Build a new OpenSRF service.</simpara>
<section id="_perl_2">
<title>Perl</title>
<simpara>The challenge: implement a service that caches responses from some
other Web service (potentially cutting down on client-side latency
for something like OpenLibrary / Google Books / xISBN services, and
avoiding timeouts if the target service is not dependable). Our
example will be to build an SFX lookup service. This has the
additional advantage of enabling <literal>XmlHttpRequest</literal> from JavaScript by
hosting the services on the same domain.</simpara>
<simpara>Let&#8217;s start with the simplest possible implementation – a CGI script.</simpara>
<programlisting language="perl" linenumbering="unnumbered"></programlisting>
<simpara>Hopefully you can follow what this CGI script is doing. It works,
but it has all the disadvantages of CGI: the environment needs to
be built up on every request, and it doesn&#8217;t remember anything
from the previous times it was called, etc.</simpara>
<section id="_turning_the_cgi_script_into_an_opensrf_service">
<title>Turning the CGI script into an OpenSRF service</title>
<simpara>So now we want to turn this into an OpenSRF service.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Start by ripping out the CGI stuff, as we won&#8217;t need that any more.
</simpara>
</listitem>
<listitem>
<simpara>
To turn this into an OpenSRF service, we create a new
Perl module (<literal>OpenILS::Application::ResolverResolver</literal>). We no
longer have to convert results between Perl and JSON values, as
OpenSRF will handle that for us. We now have to register the
method with OpenSRF.
</simpara>
<programlisting language="perl" linenumbering="unnumbered"></programlisting>
</listitem>
<listitem>
<simpara>
Copy the file into the <literal>/openils/lib/perl5/OpenILS/Application/</literal> directory
so that OpenSRF can find it in the <literal>@INC</literal> search path.
</simpara>
</listitem>
<listitem>
<simpara>
Add the service to <literal>opensrf.xml</literal> so it gets started with the
other Perl services on our host of choice:
</simpara>
<programlisting language="xml" linenumbering="unnumbered">...
&lt;open-ils.resolver&gt;
  &lt;keepalive&gt;3&lt;/keepalive&gt;
  &lt;stateless&gt;1&lt;/stateless&gt;
  &lt;language&gt;perl&lt;/language&gt;
  &lt;implementation&gt;OpenILS::Application::ResolverResolver&lt;/implementation&gt;
  &lt;max_requests&gt;17&lt;/max_requests&gt;
  &lt;unix_config&gt;
    &lt;unix_sock&gt;open-ils.resolver_unix.sock&lt;/unix_sock&gt;
    &lt;unix_pid&gt;open-ils.resolver_unix.pid&lt;/unix_pid&gt;
    &lt;max_requests&gt;1000&lt;/max_requests&gt;
    &lt;unix_log&gt;open-ils.resolver_unix.log&lt;/unix_log&gt;
    &lt;min_children&gt;5&lt;/min_children&gt;
    &lt;max_children&gt;15&lt;/max_children&gt;
    &lt;min_spare_children&gt;3&lt;/min_spare_children&gt;
    &lt;max_spare_children&gt;5&lt;/max_spare_children&gt;
  &lt;/unix_config&gt;
  &lt;app_settings&gt;
    &lt;cache_timeout&gt;86400&lt;/cache_timeout&gt;
    &lt;default_url_base&gt;http://sfx.scholarsportal.info/laurentian&lt;/default_url_base&gt;
  &lt;/app_settings&gt;
&lt;/open-ils.resolver&gt;
...
&lt;!-- In the &lt;hosts&gt; section --&gt;
&lt;localhost&gt;
  ...
  &lt;appname&gt;open-ils.resolver&lt;/appname&gt;
&lt;/localhost&gt;</programlisting>
</listitem>
<listitem>
<simpara>
Add the service to <literal>opensrf_core.xml</literal> as a publicly exposed
service via the HTTP gateway and translator:
</simpara>
<programlisting language="xml" linenumbering="unnumbered">...
&lt;!-- In the public router section --&gt;
&lt;services&gt;
  ...
  &lt;service&gt;open-ils.resolver&lt;/service&gt;
&lt;/services&gt;
...
&lt;!-- In the public gateway section --&gt;
&lt;services&gt;
&lt;gateway&gt;
  ...
  &lt;services&gt;
    &lt;service&gt;open-ils.resolver&lt;/service&gt;
  &lt;/services&gt;
&lt;/gateway&gt;</programlisting>
</listitem>
<listitem>
<simpara>
Restart the OpenSRF Perl services to refresh the OpenSRF
settings and start the service..
</simpara>
</listitem>
<listitem>
<simpara>
Restart Apache to enable the gateway and translator to pick up
the new service.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="_add_caching">
<title>Add caching</title>
<simpara>To really make this service useful, we can take advantage of OpenSRF&#8217;s
built-in support for caching via memcached. Keeping the values
returned by the resolver for 1 week is apparently good.</simpara>
<simpara>We will also take advantage of the <literal>opensrf.settings</literal> service that
holds the values defined in the <literal>opensrf.xml</literal> configuration file to
supply some of our default arguments.</simpara>
<formalpara><title>Caching OpenSRF Resolver Service</title><para>
<programlisting language="perl" linenumbering="unnumbered"></programlisting>
</para></formalpara>
</section>
<section id="_pulling_application_settings_from_literal_opensrf_xml_literal">
<title>Pulling application settings from <literal>opensrf.xml</literal></title>
<simpara>In case you missed it in the previous diff, we also started
pulling some application-specific settings from <literal>opensrf.xml</literal>
during the <literal>initialize()</literal> phase for the service.</simpara>
<simpara>In the following diff, we enable the service to pull the default URL from
<literal>opensrf.xml</literal> rather than hard-coding it into the OpenSRF service&#8230; because
that&#8217;s just the right thing to do.</simpara>
<programlisting language="perl" linenumbering="unnumbered">=== modified file 'ResolverResolver.pm'
--- ResolverResolver.pm    2009-10-22 21:00:15 +0000
+++ ResolverResolver.pm    2009-10-24 03:00:30 +0000
@@ -77,6 +77,7 @@
 my $prefix = "open-ils.resolver_"; # Prefix for caching values
 my $cache;
 my $cache_timeout;
+my $default_url_base;              # Default resolver location

 our ($ua, $parser);

@@ -86,6 +87,8 @@
     my $sclient = OpenSRF::Utils::SettingsClient-&gt;new();
     $cache_timeout = $sclient-&gt;config_value(
         "apps", "open-ils.resolver", "app_settings", "cache_timeout" ) || 300;
+    $default_url_base = $sclient-&gt;config_value(
+        "apps", "open-ils.resolver", "app_settings", "default_url_base");
 }

 sub child_init {
@@ -102,14 +105,11 @@
     my $conn = shift;
     my $id_type = shift; # keep it simple for now, either 'issn' or 'isbn'
     my $id_value = shift; # the normalized ISSN or ISBN
+    my $url_base = shift || $default_url_base;

     # We'll use this in our cache key
     my $method = "open-ils.resolver.resolve_holdings";

-    # For now we'll pass the argument with a hard-coded default
-    # Should pull these specifics from the database as part of initialize()
-    my $url_base = shift || 'http://sfx.scholarsportal.info/laurentian';
-
     # Big ugly SFX OpenURL request
     my $url_args = '?url_ver=Z39.88-2004&amp;url_ctx_fmt=infofi/fmt:kev:mtx:ctx&amp;'
         . 'ctx_enc=UTF-8&amp;ctx_ver=Z39.88-2004&amp;rfr_id=info:sid/conifer&amp;'</programlisting>
<simpara>The <literal>opensrf.settings</literal> service caches the settings defined in <literal>opensrf.xml</literal>,
so if you change a setting in the configuration files and want that change
to take effect immediately, you have to:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Restart the <literal>opensrf.settings</literal> service to refresh the cached settings.
</simpara>
</listitem>
<listitem>
<simpara>
Restart the affected service to make the new settings take effect.
</simpara>
</listitem>
</orderedlist>
<simpara>Next step: add org_unit settings for resolver type and URL on a per-org_unit basis.
OrgUnit settings can be retrieved via
<literal>OpenILS::Application::AppUtils-&gt;ou_ancestor_setting_value($org_id, $setting_name)</literal>).</simpara>
<simpara>This is where we step beyond OpenSRF and start getting into the
Evergreen database schema (<literal>config.org_unit_setting</literal> table).</simpara>
</section>
</section>
<section id="_further_reading">
<title>Further reading</title>
<simpara>OpenSRF terminology: <ulink url="http://open-ils.org/dokuwiki/doku.php?id=osrf-devel:terms">http://open-ils.org/dokuwiki/doku.php?id=osrf-devel:terms</ulink></simpara>
</section>
</section>
<section id="_part_2_evergreen_applications">
<title>Part 2: Evergreen applications</title>
<section id="_authentication">
<title>Authentication</title>
<simpara>Although many services offer methods that can be invoked without
authentication, some methods require authentication in Evergreen.
Evergreen&#8217;s authentication framework returns an <emphasis>authentication token</emphasis>
when a user has successfully logged in to represent that user
session. You can then pass the authentication token to various
methods to ensure, for example, that the requesting user has permission
to access the circulation information attached to a particular account,
or has been granted the necessary permissions at a particular library
to perform the action that they are requesting.</simpara>
<simpara>Authentication in Evergreen is performed with the assistance of the
<literal>open-ils.auth</literal> service, which has been written in C for performance
reasons because it is invoked so frequently. A successful authentication
request requires two steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Retrieve an authentication seed value by invoking the
<literal>open-ils.auth.authenticate.init</literal> method, passing the user name as
the only argument. As long as the user name contains no spaces, the
method returns a seed value calculated by the MD5 checksum of
a string composed of the concatenation of the time() system call,
process ID, and user name.
</simpara>
</listitem>
<listitem>
<simpara>
Retrieve an authentication token by invoking the
<literal>open-ils.auth.authenticate.complete</literal> method, passing
a JSON hash composed of a minimum of the following arguments
(where <emphasis>seed</emphasis> represents the value returned by the
<literal>open-ils.auth.authenticate.init</literal> method):
</simpara>
<programlisting language="java" linenumbering="unnumbered">{
    "username": username, // or "barcode": barcode,
    "password": md5sum(seed + md5sum(password)),
}</programlisting>
</listitem>
</orderedlist>
<simpara><literal>open-ils.auth.authenticate.complete</literal> also accepts the following
additional arguments:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>type</literal>: one of "staff" (default), "opac", or "temp"
</simpara>
</listitem>
<listitem>
<simpara>
<literal>org</literal>: the numeric ID of the org_unit where the login is active
</simpara>
</listitem>
<listitem>
<simpara>
<literal>workstation</literal>: the registered workstation name
</simpara>
</listitem>
</itemizedlist>
<section id="_authentication_in_perl">
<title>Authentication in Perl</title>
<simpara>The following example is taken directly from <literal>OpenILS::WWW::Proxy</literal>:</simpara>
<programlisting language="perl" linenumbering="unnumbered">sub oils_login {
    my( $username, $password, $type ) = @_;

    $type |= "staff";
    my $nametype = 'username';
    $nametype = 'barcode' if ($username =~ /^\d+$/o);

    my $seed = OpenSRF::AppSession
        -&gt;create("open-ils.auth")
        -&gt;request( 'open-ils.auth.authenticate.init', $username )
        -&gt;gather(1);

    return undef unless $seed;

    my $response = OpenSRF::AppSession
        -&gt;create("open-ils.auth")
        -&gt;request( 'open-ils.auth.authenticate.complete', {
        $nametype =&gt; $username,
            password =&gt; md5_hex($seed . md5_hex($password)),
            type =&gt; $type
        })
        -&gt;gather(1);

    return undef unless $response;

    return $response-&gt;{payload}-&gt;{authtoken};
}</programlisting>
</section>
<section id="_authentication_in_javascript">
<title>Authentication in JavaScript</title>
<simpara>The following example provides a minimal implementation of the authentication
method in JavaScript. For a more complete implementation, you would
differentiate between user names and barcodes, potentially accept the
org_unit and workstation name for more granular permissions, and provide
exception handling.</simpara>
<programlisting language="html" linenumbering="unnumbered"></programlisting>
<calloutlist>
<callout arearefs="">
<simpara>
opensrf.js defines most of the objects and methods required for a bare
JavaScript call to the OpenSRF HTTP translator.
</simpara>
</callout>
<callout arearefs="">
<simpara>
opensrf_xhr.js provides cross-browser XMLHttpRequest support for OpenSRF.
</simpara>
</callout>
<callout arearefs="">
<simpara>
JSON_v1.js converts the requests and responses between JavaScript and the
JSON format that the OpenSRF translator expects.
</simpara>
</callout>
<callout arearefs="">
<simpara>
md5.js provides the implementation of the md5sum algorithm in the
<literal>hex_md5</literal> function
</simpara>
</callout>
<callout arearefs="">
<simpara>
Create a client session that connects to the <literal>open-ils.auth</literal> service.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Create a request object that invokes the <literal>open-ils.auth.authenticate.init</literal>
method, providing the user name as the salt.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Set the <literal>timeout</literal> property on the request object to make it a
synchronous call.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Send the request. The method returns a seed value which is assigned to
the <literal>seed</literal> variable.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Create the hash of parameters that will be sent in the request to the
<literal>open-ils.auth.authenticate.complete</literal> method, including the password and
authentication type.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Assume that the credentials being sent are based on the user name rather
than the barcode. The Perl implementation tests the value of the user name
variable to determine whether it contains a digit; if it does contain a
digit, then it is considered a barcode rather than a user name. Ensure that
your implementations are consistent!
</simpara>
</callout>
<callout arearefs="">
<simpara>
Create a request object that invokes the
<literal>open-ils.auth.authenticate.complete</literal> method, passing the entire hash of
parameters. Once again, set the <literal>timeout</literal> parameter to make the request
synchronous.
</simpara>
</callout>
<callout arearefs="">
<simpara>
Assign the <literal>authtoken</literal> attribute of the returned payload to the
<literal>authtoken</literal> variable.
</simpara>
</callout>
</calloutlist>
</section>
</section>
</section>
<section id="_evergreen_data_models_and_access">
<title>Evergreen data models and access</title>
<section id="_database_schema">
<title>Database schema</title>
<simpara>The database schema is tied pretty tightly to PostgreSQL. Although PostgreSQL
adheres closely to ANSI SQL standards, the use of schemas, SQL functions
implemented in both plpgsql and plperl, and PostgreSQL&#8217;s native full-text
search would make it&#8230; challenging&#8230; to port to other database platforms.</simpara>
<simpara>A few common PostgreSQL interfaces for poking around the schema and
manipulating data are:</simpara>
<itemizedlist>
<listitem>
<simpara>
psql (the command line client)
</simpara>
</listitem>
<listitem>
<simpara>
pgadminIII (a GUI client).
</simpara>
</listitem>
</itemizedlist>
<simpara>Or you can read through the source files in Open-ILS/src/sql/Pg.</simpara>
<simpara>Let&#8217;s take a quick tour through the schemas, pointing out some highlights
and some key interdependencies:</simpara>
<itemizedlist>
<listitem>
<simpara>
actor.org_unit &#8594; asset.copy_location
</simpara>
</listitem>
<listitem>
<simpara>
actor.usr &#8594; actor.card
</simpara>
</listitem>
<listitem>
<simpara>
biblio.record_entry &#8594; asset.call_number &#8594; asset.copy
</simpara>
</listitem>
<listitem>
<simpara>
config.metabib_field &#8594; metabib.*_field_entry
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_database_access_methods">
<title>Database access methods</title>
<simpara>You could use direct access to the database via Perl DBI, JDBC, etc,
but Evergreen offers several database CRUD services for
creating / retrieving / updating / deleting data. These avoid tying
you too tightly to the current database schema and they funnel database
access through the same mechanism, rather than tying up connections
with other interfaces.</simpara>
</section>
<section id="_evergreen_interface_definition_language_idl">
<title>Evergreen Interface Definition Language (IDL)</title>
<simpara>Defines properties and required permissions for Evergreen classes.
To reduce network overhead, a given object is identified via a
class-hint and serialized as a JSON array of properties (no named properties).</simpara>
<simpara>As of 1.6, fields will be serialized in the order in which they appear
in the IDL definition file, and the is_new / is_changed / is_deleted
properties are automatically added. This has greatly reduced the size of
the <literal>fm_IDL.xml</literal> file and makes DRY people happier :)</simpara>
<itemizedlist>
<listitem>
<simpara>
&#8230; oils_persist:readonly tells us, if true, that the data lives in the database, but is pulled from the SELECT statement defined in the &lt;oils_persist:source_definition&gt; child element
</simpara>
</listitem>
</itemizedlist>
<section id="_idl_basic_example_config_language_map">
<title>IDL basic example (config.language_map)</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;class id="clm" controller="open-ils.cstore open-ils.pcrud"
        oils_obj:fieldmapper="config::language_map"
        oils_persist:tablename="config.language_map"
        reporter:label="Language Map" oils_persist:field_safe="true"&gt;      # <co id="CO5-1"/> <co id="CO5-2"/> <co id="CO5-3"/> <co id="CO5-4"/>
    &lt;fields oils_persist:primary="code" oils_persist:sequence=""&gt;          # <co id="CO5-5"/>
        &lt;field reporter:label="Language Code" name="code"
            reporter:selector="value" reporter:datatype="text"/&gt;           # <co id="CO5-6"/>
        &lt;field reporter:label="Language" name="value"
            reporter:datatype="text" oils_persist:i18n="true"/&gt;            # <co id="CO5-7"/>
    &lt;/fields&gt;
    &lt;links/&gt;
    &lt;permacrud xmlns="http://open-ils.org/spec/opensrf/IDL/permacrud/v1"&gt;  # <co id="CO5-8"/>
        &lt;actions&gt;
            &lt;create global_required="true" permission="CREATE_MARC_CODE"&gt;  # <co id="CO5-9"/>
            &lt;retrieve global_required="true"
                permission="CREATE_MARC_CODE UPDATE_MARC_CODE DELETE_MARC_CODE"&gt;
            &lt;update global_required="true" permission="UPDATE_MARC_CODE"&gt;
            &lt;delete global_required="true" permission="DELETE_MARC_CODE"&gt;
        &lt;/actions&gt;
    &lt;/permacrud&gt;
&lt;/class&gt;</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<simpara>
The <literal>class</literal> element defines the attributes and permissions for classes,
and relationships between classes.
</simpara>
<itemizedlist>
<listitem>
<simpara>
The <literal>id</literal> attribute on the <literal>class</literal> element defines the class hint that is
used everywhere in Evergreen.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>controller</literal> attribute defines the OpenSRF
services that provide access to the data for the class objects.
</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO5-2">
<simpara>
The <literal>oils_obj::fieldmapper</literal> attribute defines the name of the class that
is generated by <literal>OpenILS::Utils::Fieldmapper</literal>.
</simpara>
</callout>
<callout arearefs="CO5-3">
<simpara>
The <literal>oils_persist:tablename</literal> attribute defines the name of the table
that contains the data for the class objects.
</simpara>
</callout>
<callout arearefs="CO5-4">
<simpara>
The reporter interface uses <literal>reporter:label</literal> attribute values in
the source list to provide meaningful class and attribute names. The
<literal>open-ils.fielder</literal> service generates a set of methods that provide direct
access to the classes for which <literal>oils_persist:field_safe</literal> is <literal>true</literal>. For
example,
</simpara>
<screen>srfsh# request open-ils.fielder open-ils.fielder.clm.atomic \
    {"query":{"code":{"=":"eng"}}}

Received Data: [
  {
    "value":"English",
    "code":"eng"
  }
]</screen>
</callout>
<callout arearefs="CO5-5">
<simpara>
The <literal>fields</literal> element defines the list of fields for the class.
</simpara>
<itemizedlist>
<listitem>
<simpara>
The <literal>oils_persist:primary</literal> attribute defines the column that acts as
the primary key for the table.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>oils_persist:sequence</literal> attribute holds the name of the database
sequence.
</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO5-6">
<simpara>
Each <literal>field</literal> element defines one property of the class.
</simpara>
<itemizedlist>
<listitem>
<simpara>
The <literal>name</literal> attribute defines the getter/setter method name for the field.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>reporter:label</literal> attribute defines the attribute name as used in
the reporter interface.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>reporter:selector</literal> attribute defines the field used in the reporter
filter interface to provide a selectable list. This gives the user a more
meaningful access point than the raw numeric ID or abstract code.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>reporter:datatype</literal> attribute defines the type of data held by
this property for the purposes of the reporter.
</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO5-7">
<simpara>
The <literal>oils_persist:i18n</literal> attribute, when <literal>true</literal>, means that
translated values for the field&#8217;s contents may be accessible in
different locales.
</simpara>
</callout>
<callout arearefs="CO5-8">
<simpara>
The <literal>permacrud</literal> element defines the permissions (if any) required
to <emphasis role="strong">c</emphasis>reate, <emphasis role="strong">r</emphasis>etrieve, <emphasis role="strong">u</emphasis>pdate, and <emphasis role="strong">d</emphasis>elete data for this
class. <literal>open-ils.permacrud</literal> must be defined as a controller for the class
for the permissions to be applied.
</simpara>
</callout>
<callout arearefs="CO5-9">
<simpara>
Each action requires one or more <literal>permission</literal> values that the
user must possess to perform the action.
</simpara>
<itemizedlist>
<listitem>
<simpara>
If the <literal>global_required</literal> attribute is <literal>true</literal>, then the user must
have been granted that permission globally (depth = 0) to perform
the action.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>context_field</literal> attribute denotes the <literal>&lt;field&gt;</literal> that identifies
the org_unit at which the user must have the pertinent permission.
</simpara>
</listitem>
<listitem>
<simpara>
An action element may contain a <literal>&lt;context_field&gt;</literal> element that
defines the linked class (identified by the <literal>link</literal> attribute) and
the field in the linked class that identifies the org_unit where
the permission must be held.
</simpara>
<itemizedlist>
<listitem>
<simpara>
If the <literal>&lt;context_field&gt;</literal> element contains a <literal>jump</literal> attribute,
then it defines a link to a link to a class with a field identifying
the org_unit where the permission must be held.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</section>
<section id="_reporter_data_types_and_their_possible_values">
<title>Reporter data types and their possible values</title>
<itemizedlist>
<listitem>
<simpara>
<literal>bool</literal>: Boolean <literal>true</literal> or <literal>false</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>id</literal>: ID of the row in the database
</simpara>
</listitem>
<listitem>
<simpara>
<literal>int</literal>: integer value
</simpara>
</listitem>
<listitem>
<simpara>
<literal>interval</literal>: PostgreSQL time interval
</simpara>
</listitem>

<listitem>
<simpara>
<literal>link</literal>: link to another class, as defined in the <literal>&lt;links&gt;</literal>
element of the class definition
</simpara>
</listitem>
<listitem>
<simpara>
<literal>money</literal>: currency amount
</simpara>
</listitem>
<listitem>
<simpara>
<literal>org_unit</literal>: list of org_units
</simpara>
</listitem>
<listitem>
<simpara>
<literal>text</literal>: text value
</simpara>
</listitem>
<listitem>
<simpara>
<literal>timestamp</literal>: PostgreSQL timestamp
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_idl_example_with_linked_fields_actor_workstation">
<title>IDL example with linked fields (actor.workstation)</title>
<simpara>Just as tables often include columns with foreign keys that point
to values stored in the column of a different table, IDL classes
can contain fields that link to fields in other classes. The <literal>&lt;links&gt;</literal>
element defines which fields link to fields in other classes, and
the nature of the relationship:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;class id="aws" controller="open-ils.cstore"
        oils_obj:fieldmapper="actor::workstation"
        oils_persist:tablename="actor.workstation"
        reporter:label="Workstation"&gt;
    &lt;fields oils_persist:primary="id"
            oils_persist:sequence="actor.workstation_id_seq"&gt;
        &lt;field reporter:label="Workstation ID" name="id"
                reporter:datatype="id"/&gt;
        &lt;field reporter:label="Workstation Name" name="name"
                reporter:datatype="text"/&gt;
        &lt;field reporter:label="Owning Library" name="owning_lib"
                reporter:datatype="org_unit"/&gt;
        &lt;field reporter:label="Circulations" name="circulations"
                oils_persist:virtual="true" reporter:datatype="link"/&gt;     # <co id="CO6-1"/>
    &lt;/fields&gt;
    &lt;links&gt;                                                                # <co id="CO6-2"/>
        &lt;link field="owning_lib" reltype="has_a" key="id"
                map="" class="aou"/&gt;                                       # <co id="CO6-3"/>
        &lt;link field="circulations" reltype="has_many" key="workstation"
                map="" class="circ"/&gt;
        &lt;link field="circulation_checkins" reltype="has_many"
                key="checkin_workstation" map="" class="circ"/&gt;
    &lt;/links&gt;
&lt;/class&gt;</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<simpara>
This field includes an <literal>oils_persist:virtual</literal> attribute with the value of
<literal>true</literal>, meaning that the linked class <literal>circ</literal> is a virtual class.
</simpara>
</callout>
<callout arearefs="CO6-2">
<simpara>
The <literal>&lt;links&gt;</literal> element contains 0 or more <literal>&lt;link&gt;</literal> elements.
</simpara>
</callout>
<callout arearefs="CO6-3">
<simpara>
Each <literal>&lt;link&gt;</literal> element defines the field (<literal>field</literal>) that links to a different
class (<literal>class</literal>), the relationship (<literal>rel_type</literal>) between this field and the target
field (<literal>key</literal>). If the field in this class links to a virtual class, the (<literal>map</literal>)
attribute defines the field in the target class that returns a list of matching
objects for each object in this class.
</simpara>
</callout>
</calloutlist>
</section>
</section>
<section id="_literal_open_ils_cstore_literal_data_access_interfaces">
<title><literal>open-ils.cstore</literal> data access interfaces</title>
<simpara>For each class documented in the IDL, the <literal>open-ils.cstore</literal> service
automatically generates a set of data access methods, based on the
<literal>oils_persist:tablename</literal> class attribute.</simpara>
<simpara>For example, for the class hint <literal>clm</literal>, cstore generates the following
methods with the <literal>config.language_map</literal> qualifer:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>open-ils.cstore.direct.config.language_map.id_list {"code" { "like": "e%" } }</literal>
</simpara>
<simpara>Retrieves a list composed only of the IDs that match the query.</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.direct.config.language_map.retrieve "eng"</literal>
</simpara>
<simpara>Retrieves the object that matches a specific ID.</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.direct.config.language_map.search {"code" : "eng"}</literal>
</simpara>
<simpara>Retrieves a list of objects that match the query.</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.direct.config.language_map.create &lt;_object_&gt;</literal>
</simpara>
<simpara>Creates a new object from the passed in object.</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.direct.config.language_map.update &lt;_object_&gt;</literal>
</simpara>
<simpara>Updates the object that has been passed in.</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.direct.config.language_map.delete "eng"</literal>
</simpara>
<simpara>Deletes the object that matches the query.</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_open_ils_pcrud_data_access_interfaces">
<title>open-ils.pcrud data access interfaces</title>
<simpara>For each class documented in the IDL, the <literal>open-ils.pcrud</literal> service
automatically generates a set of data access methods, based on the
<literal>oils_persist:tablename</literal> class attribute.</simpara>
<simpara>For example, for the class hint <literal>clm</literal>, <literal>open-ils.pcrud</literal> generates the following
methods that parallel the <literal>open-ils.cstore</literal> interface:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>open-ils.pcrud.id_list.clm &lt;_authtoken_&gt;, { "code": { "like": "e%" } }</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.retrieve.clm &lt;_authtoken_&gt;, "eng"</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.search.clm &lt;_authtoken_&gt;, { "code": "eng" }</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.create.clm &lt;_authtoken_&gt;, &lt;_object_&gt;</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.update.clm &lt;_authtoken_&gt;, &lt;_object_&gt;</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.delete.clm &lt;_authtoken_&gt;, "eng"</literal>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_transaction_and_savepoint_control">
<title>Transaction and savepoint control</title>
<simpara>Both <literal>open-ils.cstore</literal> and <literal>open-ils.pcrud</literal> enable you to control database transactions
to ensure that a set of operations either all succeed, or all fail,
atomically:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>open-ils.cstore.transaction.begin</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.transaction.commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.transaction.rollback</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.transaction.begin</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.transaction.commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.transaction.rollback</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>At a more granular level, <literal>open-ils.cstore</literal> and <literal>open-ils.pcrud</literal> enable you to set database
savepoints to ensure that a set of operations either all succeed, or all
fail, atomically, within a given transaction:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>open-ils.cstore.savepoint.begin</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.savepoint.commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.cstore.savepoint.rollback</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.savepoint.begin</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.savepoint.commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>open-ils.pcrud.savepoint.rollback</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>Transactions and savepoints must be performed within a stateful
connection to the <literal>open-ils.cstore</literal> and <literal>open-ils.pcrud</literal> services.
In <literal>srfsh</literal>, you can open a stateful connection using the <literal>open</literal>
command, and then close the stateful connection using the <literal>close</literal>
command - for example:</simpara>
<screen>srfsh# open open-ils.cstore
... perform various transaction-related work
srfsh# close open-ils.cstore</screen>
<section id="_json_queries">
<title>JSON Queries</title>
<simpara>Beyond simply retrieving objects by their ID using the <literal>\*.retrieve</literal>
methods, you can issue queries against the <literal>\*.delete</literal> and <literal>\*.search</literal>
methods using JSON to filter results with simple or complex search
conditions.</simpara>
<simpara>For example, to generate a list of barcodes that are held in a
copy location that allows holds and is visible in the OPAC:</simpara>
<programlisting language="sh" linenumbering="unnumbered">srfsh# request open-ils.cstore open-ils.cstore.json_query      #\ <co id="CO7-1"/>
    {"select": {"acp":["barcode"], "acpl":["name"]},           #\ <co id="CO7-2"/>
     "from":   {"acp":"acpl"},                                 #\ <co id="CO7-3"/>
     "where":  [                                               #\ <co id="CO7-4"/>
         {"+acpl": "holdable"},                                #\ <co id="CO7-5"/>
         {"+acpl": "opac_visible"}                             #\ <co id="CO7-6"/>
     ]}

Received Data: {
  "barcode":"BARCODE1",
  "name":"Stacks"
}

Received Data: {
  "barcode":"BARCODE2",
  "name":"Stacks"
}</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<simpara>
Invoke the <literal>json_query</literal> service.
</simpara>
</callout>
<callout arearefs="CO7-2">
<simpara>
Select the <literal>barcode</literal> field from the <literal>acp</literal> class and the <literal>name</literal>
field from the <literal>acpl</literal> class.
</simpara>
</callout>
<callout arearefs="CO7-3">
<simpara>
Join the <literal>acp</literal> class to the <literal>acpl</literal> class based on the linked field
defined in the IDL.
</simpara>
</callout>
<callout arearefs="CO7-4">
<simpara>
Add a <literal>where</literal> clause to filter the results. We have more than one
condition beginning with the same key, so we wrap the conditions inside
an array.
</simpara>
</callout>
<callout arearefs="CO7-5">
<simpara>
The first condition tests whether the boolean value of the <literal>holdable</literal>
field on the <literal>acpl</literal> class is true.
</simpara>
</callout>
<callout arearefs="CO7-6">
<simpara>
The second condition tests whether the boolean value of the
<literal>opac_visible</literal> field on the <literal>acpl</literal> class is true.
</simpara>
</callout>
</calloutlist>
<simpara>For thorough coverage of the breadth of support offered by JSON
query syntax, see <ulink url="http://open-ils.org/dokuwiki/doku.php?id=documentation:technical:jsontutorial">JSON Queries: A Tutorial</ulink>.</simpara>
</section>
<section id="_fleshing_linked_objects">
<title>Fleshing linked objects</title>
<simpara>A simplistic approach to retrieving a set of objects that are linked to
an object that you are retrieving - for example, a set of call numbers
linked to the barcodes that a given user has borrowed - would be to:
  1. Retrieve the list of circulation objects (<literal>circ</literal> class)
for a given user (<literal>usr</literal> class).
  2. For each circulation object, look up the target copy (<literal>target_copy</literal>
field, linked to the <literal>acp</literal> class).
  3. For each copy, look up the call number for that copy (<literal>call_number</literal>
field, linked to the <literal>acn</literal> class).</simpara>
<simpara>However, this would result in potentially hundreds of round-trip
queries from the client to the server. Even with low-latency connections,
the network overhead would be considerable. So, built into the <literal>open-ils.cstore</literal> and
<literal>open-ils.pcrud</literal> access methods is the ability to <emphasis>flesh</emphasis> linked fields -
that is, rather than return an identifier to a given linked field,
the method can return the entire object as part of the initial response.</simpara>
<simpara>Most of the interfaces that return class instances from the IDL offer the
ability to flesh returned fields. For example, the
<literal>open-ils.cstore.direct.\*.retrieve</literal> methods allow you to specify a
JSON structure defining the fields you wish to flesh in the returned object.</simpara>
<formalpara><title>Fleshing fields in objects returned by <literal>open-ils.cstore</literal></title><para>
<programlisting language="sh" linenumbering="unnumbered">srfsh# request open-ils.cstore open-ils.cstore.direct.asset.copy.retrieve 1, \
    {
        "flesh": 1,                                                       #\ <co id="CO8-1"/>
        "flesh_fields": {                                                 #\ <co id="CO8-2"/>
            "acp": ["location"]
        }
    }</programlisting>
</para></formalpara>
<calloutlist>
<callout arearefs="CO8-1">
<simpara>
The <literal>flesh</literal> argument is the depth at which objects should be fleshed.
For example, to flesh out a field that links to another object that includes
a field that links to another object, you would specify a depth of 2.
</simpara>
</callout>
<callout arearefs="CO8-2">
<simpara>
The <literal>flesh_fields</literal> argument contains a list of objects with the fields
to flesh for each object.
</simpara>
</callout>
</calloutlist>
<simpara>Let&#8217;s flesh things a little deeper. In addition to the copy location,
let&#8217;s also flesh the call number attached to the copy, and then flesh
the bibliographic record attached to the call number.</simpara>
<formalpara><title>Fleshing fields in fields of objects returned by <literal>open-ils.cstore</literal></title><para>
<programlisting language="java" linenumbering="unnumbered">request open-ils.cstore open-ils.cstore.direct.asset.copy.retrieve 1, \
    {
        "flesh": 2,
        "flesh_fields": {
            "acp": ["location", "call_number"],
            "acn": ["record"]
         }
    }</programlisting>
</para></formalpara>
</section>
</section>
<section id="_adding_an_idl_entry_for_resolverresolver">
<title>Adding an IDL entry for ResolverResolver</title>
<simpara>Most OpenSRF methods in Evergreen define their object interface in the
IDL. Without an entry in the IDL, the prospective caller of a given
method is forced to either call the method and inspect the returned
contents, or read the source to work out the structure of the JSON
payload. At this stage of the tutorial, we have not defined an entry
in the IDL to represent the object returned by the
<literal>open-ils.resolver.resolve_holdings</literal> method. It is time to complete
that task.</simpara>
<simpara>The <literal>open-ils.resolver</literal> service is unlike many of the other classes
defined in the IDL because its data is not stored in the Evergreen
database. Instead, the data is requested from an external Web service
and only temporarily cached in <literal>memcached</literal>. Fortunately, the IDL
enables us to represent this kind of class by setting the
<literal>oils_persist:virtual</literal> class attribute to <literal>true</literal>.</simpara>
<simpara>So, let&#8217;s add an entry to the IDL for the <literal>open-ils.resolver.resolve_holdings</literal>
service:</simpara>
<programlisting language="xml" linenumbering="unnumbered"></programlisting>
<simpara>And let&#8217;s make <literal>ResolverResolver.pm</literal> return an array composed of our new
<literal>rhr</literal> classes rather than raw JSON objects:</simpara>
<programlisting language="perl" linenumbering="unnumbered"></programlisting>
<simpara>Once we add the new entry to the IDL and copy the revised <literal>ResolverResolver.pm</literal>
Perl module to <literal>/openils/lib/perl5/OpenILS/Application/</literal>, we need to:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Copy the updated IDL to both the <literal>/openils/conf/</literal> and
<literal>/openils/var/web/reports/</literal> directories. The Dojo approach to
parsing the IDL uses the IDL stored in the reports directory.
</simpara>
</listitem>
<listitem>
<simpara>
Restart the Perl services to make the new IDL visible to the services
and refresh the <literal>open-ils.resolver</literal> implementation
</simpara>
</listitem>
<listitem>
<simpara>
Rerun <literal>/openils/bin/autogen.sh</literal> to regenerate the JavaScript versions
of the IDL required by the HTTP translator and gateway.
</simpara>
</listitem>
</orderedlist>
<simpara>We also need to adjust our JavaScript client to use the nifty new
objects that <literal>open-ils.resolver.resolve_holdings</literal> now returns.
The best approach is to use the support in Evergreen&#8217;s Dojo extensions
to generate the JavaScript classes directly from the IDL XML file.</simpara>
<formalpara><title>Accessing classes defined in the IDL via Fieldmapper</title><para>
<programlisting language="html" linenumbering="unnumbered"></programlisting>
</para></formalpara>
<calloutlist>
<callout arearefs="">
<simpara>
Load the Dojo core.
</simpara>
</callout>
<callout arearefs="">
<simpara>
<literal>fieldmapper.AutoIDL</literal> reads <literal>/openils/var/reports/fm_IDL.xml</literal> to
generate a list of class properties.
</simpara>
</callout>
<callout arearefs="">
<simpara>
<literal>fieldmapper.dojoData</literal> seems to provide a store for Evergreen data
accessed via Dojo.
</simpara>
</callout>
<callout arearefs="">
<simpara>
<literal>fieldmapper.Fieldmapper</literal> converts the list of class properties into
actual classes.
</simpara>
</callout>
<callout arearefs="">
<simpara>
<literal>fieldmapper.standardRequest</literal> invokes an OpenSRF method and returns
an array of objects.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The first argument to <literal>fieldmapper.standardRequest</literal> is an array
containing the OpenSRF service name and method name.
</simpara>
</callout>
<callout arearefs="">
<simpara>
The second argument to <literal>fieldmapper.standardRequest</literal> is an array
containing the arguments to pass to the OpenSRF method.
</simpara>
</callout>
<callout arearefs="">
<simpara>
As Fieldmapper has instantiated the returned objects based on their
class hints, we can invoke getter/setter methods on the objects.
</simpara>
</callout>
</calloutlist>
</section>
</section>
<section id="_license">
<title>License</title>
<simpara>This work is licensed under a <ulink url="http://creativecommons.org/licenses/by-sa/2.5/ca/">Creative Commons Attribution-Share Alike 2.5 Canada License</ulink>.</simpara>
</section>
</chapter>
