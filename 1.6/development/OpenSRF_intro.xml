<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="opensrf" xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="EN"
    xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink">
	<chapterinfo>
    		<title>OpenSRF</title>
	</chapterinfo>
	<abstract id="openSRF_abstract">
		<simpara>One of the claimed advantages of
		Evergreen over alternative integrated library systems is the underlying Open
		Service Request Framework (OpenSRF, pronounced "open surf") architecture. This
		article introduces OpenSRF, demonstrates how to build OpenSRF services through
		simple code examples, and explains the technical foundations on which OpenSRF
		is built. This chapter was taken from Dan Scott's <emphasis>Easing gently into OpenSRF</emphasis> article, June, 2010.</simpara>
	</abstract>
	<section id="_introducing_opensrf">
		<title>Introducing OpenSRF</title>
		<simpara>OpenSRF is a message routing network that offers scalability and failover
		support for individual services and entire servers with minimal development and
		deployment overhead. You can use OpenSRF to build loosely-coupled applications
		that can be deployed on a single server or on clusters of geographically
		distributed servers using the same code and minimal configuration changes.
		Although copyright statements on some of the OpenSRF code date back to Mike
		Rylander&#8217;s original explorations in 2000, Evergreen was the first major
		application to be developed with, and to take full advantage of, the OpenSRF
		architecture starting in 2004. The first official release of OpenSRF was 0.1 in
		February 2005 (<ulink url="http://evergreen-ils.org/blog/?p=21">http://evergreen-ils.org/blog/?p=21</ulink>), but OpenSRF&#8217;s development
		continues a steady pace of enhancement and refinement, with the release of
		1.0.0 in October 2008 and the most recent release of 1.2.2 in February 2010.</simpara>
		<simpara>OpenSRF is a distinct break from the architectural approach used by previous
		library systems and has more in common with modern Web applications. The
		traditional "scale-up" approach to serve more transactions is to purchase a
		server with more CPUs and more RAM, possibly splitting the load between a Web
		server, a database server, and a business logic server. Evergreen, however, is
		built on the Open Service Request Framework (OpenSRF) architecture, which
		firmly embraces the "scale-out" approach of spreading transaction load over
		cheap commodity servers. The <ulink url="http://evergreen-ils.org/blog/?p=56">initial GPLS
		PINES hardware cluster</ulink>, while certainly impressive, may have offered the
		misleading impression that Evergreen requires a lot of hardware to run.
		However, Evergreen and OpenSRF easily scale down to a single server; many
		Evergreen libraries run their entire library system on a single server, and
		most OpenSRF and Evergreen development occurs on a virtual machine running on a
		single laptop or desktop image.</simpara>
		<simpara>Another common concern is that the flexibility of OpenSRF&#8217;s distributed
		architecture makes it complex to configure and to write new applications. This
		article demonstrates that OpenSRF itself is an extremely simple architecture on
		which one can easily build applications of many kinds – not just library
		applications – and that you can use a number of different languages to call and
		implement OpenSRF methods with a minimal learning curve. With an application
		built on OpenSRF, when you identify a bottleneck in your application&#8217;s business
		logic layer, you can adjust the number of the processes serving that particular
		bottleneck on each of your servers; or if the problem is that your service is
		resource-hungry, you could add an inexpensive server to your cluster and
		dedicate it to running that resource-hungry service.</simpara>
		<simplesect id="_programming_language_support">
			<title>Programming language support</title>
			<simpara>If you need to develop an entirely new OpenSRF service, you can choose from a
			number of different languages in which to implement that service. OpenSRF
			client language bindings have been written for C, Java, JavaScript, Perl, and
			Python, and service language bindings have been written for C, Perl, and Python.
			This article uses Perl examples as a lowest common denominator programming
			language. Writing an OpenSRF binding for another language is a relatively small
			task if that language offers libraries that support the core technologies on
			which OpenSRF depends:</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			<ulink url="http://tools.ietf.org/html/rfc3920">Extensible Messaging and Presence
			Protocol</ulink> (XMPP, sometimes referred to as Jabber) - provides the base messaging
			infrastructure between OpenSRF clients and services
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			<ulink url="http://json.org">JavaScript Object Notation</ulink> (JSON) - serializes the content
			of each XMPP message in a standardized and concise format
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			<ulink url="http://memcached.org">memcached</ulink> - provides the caching service
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			<ulink url="http://tools.ietf.org/html/rfc5424">syslog</ulink> - the standard UNIX logging
			service
			</simpara>
			</listitem>
			</itemizedlist>
			<simpara>Unfortunately, the
			<ulink url="http://evergreen-ils.org/dokuwiki/doku.php?id=osrf-devel:primer">OpenSRF
			reference documentation</ulink>, although augmented by the
			<ulink url="http://evergreen-ils.org/dokuwiki/doku.php?id=osrf-devel:terms">OpenSRF
			glossary</ulink>, blog posts like <ulink url="http://evergreen-ils.org/blog/?p=36">the description
			of OpenSRF and Jabber</ulink>, and even this article, is not a sufficient substitute
			for a complete specification on which one could implement a language binding.
			The recommended option for would-be developers of another language binding is
			to use the Python implementation as the cleanest basis for a port to another
			language.</simpara>
		</simplesect>
	</section>
	<section id="writing_an_opensrf_service">
		<title>Writing an OpenSRF Service</title>
		<simpara>Imagine an application architecture in which 10 lines of Perl or Python, using
		the data types native to each language, are enough to implement a method that
		can then be deployed and invoked seamlessly across hundreds of servers.  You
		have just imagined developing with OpenSRF – it is truly that simple. Under the
		covers, of course, the OpenSRF language bindings do an incredible amount of
		work on behalf of the developer. An OpenSRF application consists of one or more
		OpenSRF services that expose methods: for example, the <literal>opensrf.simple-text</literal>
		<ulink url="http://svn.open-ils.org/trac/OpenSRF/browser/trunk/src/perl/lib/OpenSRF/Application/Demo/SimpleText.pm">demonstration
		service</ulink> exposes the <literal>opensrf.simple-text.split()</literal> and
		<literal>opensrf.simple-text.reverse()</literal> methods. Each method accepts zero or more
		arguments and returns zero or one results. The data types supported by OpenSRF
		arguments and results are typical core language data types: strings, numbers,
		booleans, arrays, and hashes.</simpara>
		<simpara>To implement a new OpenSRF service, perform the following steps:</simpara>
		<orderedlist numeration="arabic">
		<listitem>
		<simpara>
		Include the base OpenSRF support libraries
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		Write the code for each of your OpenSRF methods as separate procedures
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		Register each method
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		Add the service definition to the OpenSRF configuration files
		</simpara>
		</listitem>
		</orderedlist>
		<simpara>For example, the following code implements an OpenSRF service. The service
		includes one method named <literal>opensrf.simple-text.reverse()</literal> that accepts one
		string as input and returns the reversed version of that string:</simpara>
		<programlisting language="perl" linenumbering="unnumbered">#!/usr/bin/perl

		package OpenSRF::Application::Demo::SimpleText;

		use strict;

		use OpenSRF::Application;
		use parent qw/OpenSRF::Application/;

		sub text_reverse {
		    my ($self , $conn, $text) = @_;
		    my $reversed_text = scalar reverse($text);
		    return $reversed_text;
		}

		__PACKAGE__-&gt;register_method(
		    method    =&gt; 'text_reverse',
		    api_name  =&gt; 'opensrf.simple-text.reverse'
		);</programlisting>
		<simpara>Ten lines of code, and we have a complete OpenSRF service that exposes a single
		method and could be deployed quickly on a cluster of servers to meet your
		application&#8217;s ravenous demand for reversed strings! If you&#8217;re unfamiliar with
		Perl, the <literal>use OpenSRF::Application; use parent qw/OpenSRF::Application/;</literal>
		lines tell this package to inherit methods and properties from the
		<literal>OpenSRF::Application</literal> module. For example, the call to
		<literal>__PACKAGE__-&gt;register_method()</literal> is defined in <literal>OpenSRF::Application</literal> but due to
		inheritance is available in this package (named by the special Perl symbol
		<literal>__PACKAGE__</literal> that contains the current package name). The <literal>register_method()</literal>
		procedure is how we introduce a method to the rest of the OpenSRF world.</simpara>
		<simplesect id="serviceRegistration">
			<title>Registering a service with the OpenSRF configuration files</title>
			<simpara>Two files control most of the configuration for OpenSRF:</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			<literal>opensrf.xml</literal> contains the configuration for the service itself, as well as
			a list of which application servers in your OpenSRF cluster should start
			the service.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			<literal>opensrf_core.xml</literal> (often referred to as the "bootstrap configuration"
			file) contains the OpenSRF networking information, including the XMPP server
			connection credentials for the public and private routers. You only need to touch
			this for a new service if the new service needs to be accessible via the
			public router.
			</simpara>
			</listitem>
			</itemizedlist>
			<simpara>Begin by defining the service itself in <literal>opensrf.xml</literal>. To register the
			<literal>opensrf.simple-text</literal> service, add the following section to the <literal>&lt;apps&gt;</literal>
			element (corresponding to the XPath <literal>/opensrf/default/apps/</literal>):</simpara>
			<programlisting language="xml" linenumbering="unnumbered">&lt;apps&gt;
			  &lt;opensrf.simple-text&gt; <co id="CO1-1"/> 
			    &lt;keepalive&gt;3&lt;/keepalive&gt;<co id="CO1-2"/> 
			    &lt;stateless&gt;1&lt;/stateless&gt;<co id="CO1-3"/>
			    &lt;language&gt;perl&lt;/language&gt;<co id="CO1-4"/> 
			    &lt;implementation&gt;OpenSRF::Application::Demo::SimpleText&lt;/implementation&gt;<co id="CO1-5"/> 
			    &lt;max_requests&gt;100&lt;/max_requests&gt;<co id="CO1-6"/> 
			    &lt;unix_config&gt;
			      &lt;max_requests&gt;1000&lt;/max_requests&gt; <co id="CO1-7"/> 
			      &lt;unix_log&gt;opensrf.simple-text_unix.log&lt;/unix_log&gt; <co id="CO1-8"/> 
			      &lt;unix_sock&gt;opensrf.simple-text_unix.sock&lt;/unix_sock&gt;<co id="CO1-9"/> 
			      &lt;unix_pid&gt;opensrf.simple-text_unix.pid&lt;/unix_pid&gt; <co id="CO1-10"/> 
			      &lt;min_children&gt;5&lt;/min_children&gt;  <co id="CO1-11"/> 
			      &lt;max_children&gt;15&lt;/max_children&gt;<co id="CO1-12"/> 
			      &lt;min_spare_children&gt;2&lt;/min_spare_children&gt;<co id="CO1-13"/> 
			      &lt;max_spare_children&gt;5&lt;/max_spare_children&gt; <co id="CO1-14"/> 
			    &lt;/unix_config&gt;
			  &lt;/opensrf.simple-text&gt;

			  &lt;!-- other OpenSRF services registered here... --&gt;
			&lt;/apps&gt;</programlisting>
			<calloutlist>
			<callout arearefs="CO1-1">
			<simpara>
			The element name is the name that the OpenSRF control scripts use to refer
			to the service.
			</simpara>
			</callout>
			<callout arearefs="CO1-2">
			<simpara>
			The <literal>&lt;keepalive&gt;</literal> element specifies the interval (in seconds) between
			checks to determine if the service is still running.
			</simpara>
			</callout>
			<callout arearefs="CO1-3">
			<simpara>
			The <literal>&lt;stateless&gt;</literal> element specifies whether OpenSRF clients can call
			methods from this service without first having to create a connection to a
			specific service backend process for that service. If the value is <literal>1</literal>, then
			the client can simply issue a request and the router will forward the request
			to an available service and the result will be returned directly to the client.
			</simpara>
			</callout>
			<callout arearefs="CO1-4">
			<simpara>
			The <literal>&lt;language&gt;</literal> element specifies the programming language in which the
			service is implemented.
			</simpara>
			</callout>
			<callout arearefs="CO1-5">
			<simpara>
			The <literal>&lt;implementation&gt;</literal> element pecifies the name of the library or module
			in which the service is implemented.
			</simpara>
			</callout>
			<callout arearefs="CO1-6">
			<simpara>
			(C implementations only): The <literal>&lt;max_requests&gt;</literal> element, as a direct child
			of the service element name, specifies the maximum number of requests a process
			serves before it is killed and replaced by a new process.
			</simpara>
			</callout>
			<callout arearefs="CO1-7">
			<simpara>
			(Perl implementations only): The <literal>&lt;max_requests&gt;</literal> element, as a direct
			child of the <literal>&lt;unix_config&gt;</literal> element, specifies the maximum number of requests
			a process serves before it is killed and replaced by a new process.
			</simpara>
			</callout>
			<callout arearefs="CO1-8">
			<simpara>
			The <literal>&lt;unix_log&gt;</literal> element specifies the name of the log file for
			language-specific log messages such as syntax warnings.
			</simpara>
			</callout>
			<callout arearefs="CO1-9">
			<simpara>
			The <literal>&lt;unix_sock&gt;</literal> element specifies the name of the UNIX socket used for
			inter-process communications.
			</simpara>
			</callout>
			<callout arearefs="CO1-10">
			<simpara>
			The <literal>&lt;unix_pid&gt;</literal> element specifies the name of the PID file for the
			master process for the service.
			</simpara>
			</callout>
			<callout arearefs="CO1-11">
			<simpara>
			The <literal>&lt;min_children&gt;</literal> element specifies the minimum number of child
			processes that should be running at any given time.
			</simpara>
			</callout>
			<callout arearefs="CO1-12">
			<simpara>
			The <literal>&lt;max_children&gt;</literal> element specifies the maximum number of child
			processes that should be running at any given time.
			</simpara>
			</callout>
			<callout arearefs="CO1-13">
			<simpara>
			The <literal>&lt;min_spare_children&gt;</literal> element specifies the minimum number of idle
			child processes that should be available to handle incoming requests.  If there
			are fewer than this number of spare child processes, new processes will be
			spawned.
			</simpara>
			</callout>
			<callout arearefs="CO1-14">
			<simpara>
			The`&lt;max_spare_children&gt;` element specifies the maximum number of idle
			child processes that should be available to handle incoming requests. If there
			are more than this number of spare child processes, the extra processes will be
			killed.
			</simpara>
			</callout>
			</calloutlist>
			<simpara>To make the service accessible via the public router, you must also
			edit the <literal>opensrf_core.xml</literal> configuration file to add the service to the list
			of publicly accessible services:</simpara>
			<formalpara><title>Making a service publicly accessible in <literal>opensrf_core.xml</literal></title><para>
			<programlisting language="xml" linenumbering="unnumbered">&lt;router&gt;<co id="CO2-1"/> 
			    &lt;!-- This is the public router. On this router, we only register applications
			     which should be accessible to everyone on the opensrf network --&gt;
			    &lt;name&gt;router&lt;/name&gt;
			    &lt;domain&gt;public.localhost&lt;/domain&gt;<co id="CO2-2"/>
			    &lt;services&gt;
				&lt;service&gt;opensrf.math&lt;/service&gt;
				&lt;service&gt;opensrf.simple-text&lt;/service&gt; <co id="CO2-3"/> 
			    &lt;/services&gt;
			&lt;/router&gt;</programlisting>
			</para></formalpara>
			<calloutlist>
			<callout arearefs="CO2-1">
			<simpara>
			This section of the <literal>opensrf_core.xml</literal> file is located at XPath
			<literal>/config/opensrf/routers/</literal>.
			</simpara>
			</callout>
			<callout arearefs="CO2-2">
			<simpara>
			<literal>public.localhost</literal> is the canonical public router domain in the OpenSRF
			installation instructions.
			</simpara>
			</callout>
			<callout arearefs="CO2-3">
			<simpara>
			Each <literal>&lt;service&gt;</literal> element contained in the <literal>&lt;services&gt;</literal> element
			offers their services via the public router as well as the private router.
			</simpara>
			</callout>
			</calloutlist>
			<simpara>Once you have defined the new service, you must restart the OpenSRF Router
			to retrieve the new configuration and start or restart the service itself.</simpara>
			<simpara>Complete working examples of the <link linkend="opensrf-core-xml">opensrf_core.xml</link> and
			<link linkend="opensrf-xml">opensrf.xml</link> configuration files are included with this article
			for your reference.</simpara>
		</simplesect>
		<simplesect id="_calling_an_opensrf_method">
			<title>Calling an OpenSRF method</title>
			<simpara>OpenSRF clients in any supported language can invoke OpenSRF services in any
			supported language. So let&#8217;s see a few examples of how we can call our fancy
			new <literal>opensrf.simple-text.reverse()</literal> method:</simpara>
			<simplesect id="_calling_opensrf_methods_from_the_srfsh_client">
				<title>Calling OpenSRF methods from the srfsh client</title>
				<simpara><literal>srfsh</literal> is a command-line tool installed with OpenSRF that you can use to call
				OpenSRF methods. To call an OpenSRF method, issue the <literal>request</literal> command and
				pass the OpenSRF service and method name as the first two arguments; then pass
				one or more JSON objects delimited by commas as the arguments to the method
				being invoked.</simpara>
				<simpara>The following example calls the <literal>opensrf.simple-text.reverse</literal> method of the
				<literal>opensrf.simple-text</literal> OpenSRF service, passing the string <literal>"foobar"</literal> as the
				only method argument:</simpara>
				<programlisting language="sh" linenumbering="unnumbered">$ srfsh
				srfsh # request opensrf.simple-text opensrf.simple-text.reverse "foobar"

				Received Data: "raboof"

				=------------------------------------
				Request Completed Successfully
				Request Time in seconds: 0.016718
				=------------------------------------</programlisting>
			</simplesect>
			<simplesect id="opensrfIntrospection">
				<title>Getting documentation for OpenSRF methods from the srfsh client</title>
				<simpara>The <literal>srfsh</literal> client also gives you command-line access to retrieving metadata
				about OpenSRF services and methods. For a given OpenSRF method, for example,
				you can retrieve information such as the minimum number of required arguments,
				the data type and a description of each argument, the package or library in
				which the method is implemented, and a description of the method. To retrieve
				the documentation for an opensrf method from <literal>srfsh</literal>, issue the <literal>introspect</literal>
				command, followed by the name of the OpenSRF service and (optionally) the
				name of the OpenSRF method. If you do not pass a method name to the <literal>introspect</literal>
				command, <literal>srfsh</literal> lists all of the methods offered by the service. If you pass
				a partial method name, <literal>srfsh</literal> lists all of the methods that match that portion
				of the method name.</simpara>
				<note><simpara>The quality and availability of the descriptive information for each
				method depends on the developer to register the method with complete and
				accurate information. The quality varies across the set of OpenSRF and
				Evergreen APIs, although some effort is being put towards improving the
				state of the internal documentation.</simpara></note>
				<programlisting language="sh" linenumbering="unnumbered">srfsh# introspect opensrf.simple-text "opensrf.simple-text.reverse"
				--&gt; opensrf.simple-text

				Received Data: {
				  "__c":"opensrf.simple-text",
				  "__p":{
				    "api_level":1,
				    "stream":0,      <co id="CO3-1"/>
				    "object_hint":"OpenSRF_Application_Demo_SimpleText",
				    "remote":0,
				    "package":"OpenSRF::Application::Demo::SimpleText", <co id="CO3-2"/>
				    "api_name":"opensrf.simple-text.reverse",<co id="CO3-3"/>
				    "server_class":"opensrf.simple-text",
				    "signature":{ <co id="CO3-4"/>
				      "params":[  <co id="CO3-5"/>
					{
					  "desc":"The string to reverse",
					  "name":"text",
					  "type":"string"
					}
				      ],
				      "desc":"Returns the input string in reverse order\n", <co id="CO3-6"/>
				      "return":{                                            <co id="CO3-7"/>
					"desc":"Returns the input string in reverse order",
					"type":"string"
				      }
				    },
				    "method":"text_reverse",  <co id="CO3-8"/>
				    "argc":1 <co id="CO3-9"/>
				  }
				}</programlisting>
				<calloutlist>
				<callout arearefs="CO3-1">
				<simpara>
				<literal>stream</literal> denotes whether the method supports streaming responses or not.
				</simpara>
				</callout>
				<callout arearefs="CO3-2">
				<simpara>
				<literal>package</literal> identifies which package or library implements the method.
				</simpara>
				</callout>
				<callout arearefs="CO3-3">
				<simpara>
				<literal>api_name</literal> identifies the name of the OpenSRF method.
				</simpara>
				</callout>
				<callout arearefs="CO3-4">
				<simpara>
				<literal>signature</literal> is a hash that describes the parameters for the method.
				</simpara>
				</callout>
				<callout arearefs="CO3-5">
				<simpara>
				<literal>params</literal> is an array of hashes describing each parameter in the method;
				each parameter has a description (<literal>desc</literal>), name (<literal>name</literal>), and type (<literal>type</literal>).
				</simpara>
				</callout>
				<callout arearefs="CO3-6">
				<simpara>
				<literal>desc</literal> is a string that describes the method itself.
				</simpara>
				</callout>
				<callout arearefs="CO3-7">
				<simpara>
				<literal>return</literal> is a hash that describes the return value for the method; it
				contains a description of the return value (<literal>desc</literal>) and the type of the
				returned value (<literal>type</literal>).
				</simpara>
				</callout>
				<callout arearefs="CO3-8">
				<simpara>
				<literal>method</literal> identifies the name of the function or method in the source
				implementation.
				</simpara>
				</callout>
				<callout arearefs="CO3-9">
				<simpara>
				<literal>argc</literal> is an integer describing the minimum number of arguments that
				must be passed to this method.
				</simpara>
				</callout>
				</calloutlist>
			</simplesect>
			<simplesect id="_calling_opensrf_methods_from_perl_applications">
				<title>Calling OpenSRF methods from Perl applications</title>
				<simpara>To call an OpenSRF method from Perl, you must connect to the OpenSRF service,
				issue the request to the method, and then retrieve the results.</simpara>
				<programlisting language="perl" linenumbering="unnumbered">#/usr/bin/perl
				use strict;
				use OpenSRF::AppSession;
				use OpenSRF::System;

				OpenSRF::System-&gt;bootstrap_client(config_file =&gt; '/openils/conf/opensrf_core.xml');<co id="CO4-1"/>

				my $session = OpenSRF::AppSession-&gt;create("opensrf.simple-text");<co id="CO4-2"/>

				print "substring: Accepts a string and a number as input, returns a string\n";
				my $result = $session-&gt;request("opensrf.simple-text.substring", "foobar", 3);<co id="CO4-3"/>
				my $request = $result-&gt;gather(); <co id="CO4-4"/>
				print "Substring: $request\n\n";

				print "split: Accepts two strings as input, returns an array of strings\n";
				$request = $session-&gt;request("opensrf.simple-text.split", "This is a test", " ");<co id="CO4-5"/>
				my $output = "Split: [";
				my $element;
				while ($element = $request-&gt;recv()) {   <co id="CO4-6"/>
				    $output .= $element-&gt;content . ", ";  <co id="CO4-7"/>
				}
				$output =~ s/, $/]/;
				print $output . "\n\n";

				print "statistics: Accepts an array of strings as input, returns a hash\n";
				my @many_strings = [
				    "First I think I'll have breakfast",
				    "Then I think that lunch would be nice",
				    "And then seventy desserts to finish off the day"
				];

				$result = $session-&gt;request("opensrf.simple-text.statistics", @many_strings); <co id="CO4-8"/>
				$request = $result-&gt;gather();    <co id="CO4-9"/>
				print "Length: " . $result-&gt;{'length'} . "\n";
				print "Word count: " . $result-&gt;{'word_count'} . "\n";

				$session-&gt;disconnect();       <co id="CO4-10"/></programlisting>
				<calloutlist>
				<callout arearefs="CO4-1">
				<simpara>
				The <literal>OpenSRF::System-&gt;bootstrap_client()</literal> method reads the OpenSRF
				configuration information from the indicated file and creates an XMPP client
				connection based on that information.
				</simpara>
				</callout>
				<callout arearefs="CO4-2">
				<simpara>
				The <literal>OpenSRF::AppSession-&gt;create()</literal> method accepts one argument - the name
				of the OpenSRF service to which you want to want to make one or more requests -
				and returns an object prepared to use the client connection to make those
				requests.
				</simpara>
				</callout>
				<callout arearefs="CO4-3">
				<simpara>
				The <literal>OpenSRF::AppSession-&gt;request()</literal> method accepts a minimum of one
				argument - the name of the OpenSRF method to which you want to make a request -
				followed by zero or more arguments to pass to the OpenSRF method as input
				values. This example passes a string and an integer to the
				<literal>opensrf.simple-text.substring</literal> method defined by the <literal>opensrf.simple-text</literal>
				OpenSRF service.
				</simpara>
				</callout>
				<callout arearefs="CO4-4">
				<simpara>
				The <literal>gather()</literal> method, called on the result object returned by the
				<literal>request()</literal> method, iterates over all of the possible results from the result
				object and returns a single variable.
				</simpara>
				</callout>
				<callout arearefs="CO4-5">
				<simpara>
				This <literal>request()</literal> call passes two strings to the <literal>opensrf.simple-text.split</literal>
				method defined by the <literal>opensrf.simple-text</literal> OpenSRF service and returns (via
				<literal>gather()</literal>) a reference to an array of results.
				</simpara>
				</callout>
				<callout arearefs="CO4-6">
				<simpara>
				The <literal>opensrf.simple-text.split()</literal> method is a streaming method that
				returns an array of results with one element per <literal>recv()</literal> call on the
				result object. We could use the <literal>gather()</literal> method to retrieve all of the
				results in a single array reference, but instead we simply iterate over
				the result variable until there are no more results to retrieve.
				</simpara>
				</callout>
				<callout arearefs="CO4-7">
				<simpara>
				While the <literal>gather()</literal> convenience method returns only the content of the
				complete set of results for a given request, the <literal>recv()</literal> method returns an
				OpenSRF result object with <literal>status</literal>, <literal>statusCode</literal>, and <literal>content</literal> fields as
				we saw in <link linkend="OpenSRFOverHTTP">the HTTP results example</link>.
				</simpara>
				</callout>
				<callout arearefs="CO4-8">
				<simpara>
				This <literal>request()</literal> call passes an array to the
				<literal>opensrf.simple-text.statistics</literal> method defined by the <literal>opensrf.simple-text</literal>
				OpenSRF service.
				</simpara>
				</callout>
				<callout arearefs="CO4-9">
				<simpara>
				The result object returns a hash reference via <literal>gather()</literal>. The hash
				contains the <literal>length</literal> and <literal>word_count</literal> keys we defined in the method.
				</simpara>
				</callout>
				<callout arearefs="CO4-10">
				<simpara>
				The <literal>OpenSRF::AppSession-&gt;disconnect()</literal> method closes the XMPP client
				connection and cleans up resources associated with the session.
				</simpara>
				</callout>
				</calloutlist>
			</simplesect>
		</simplesect>
		<simplesect id="_accepting_and_returning_more_interesting_data_types">
			<title>Accepting and returning more interesting data types</title>
			<simpara>Of course, the example of accepting a single string and returning a single
			string is not very interesting. In real life, our applications tend to pass
			around multiple arguments, including arrays and hashes. Fortunately, OpenSRF
			makes that easy to deal with; in Perl, for example, returning a reference to
			the data type does the right thing. In the following example of a method that
			returns a list, we accept two arguments of type string: the string to be split,
			and the delimiter that should be used to split the string.</simpara>
			<formalpara><title>Basic text splitting method</title><para>
			<programlisting language="perl" linenumbering="unnumbered">sub text_split {
			    my $self = shift;
			    my $conn = shift;
			    my $text = shift;
			    my $delimiter = shift || ' ';

			    my @split_text = split $delimiter, $text;
			    return \@split_text;
			}

			__PACKAGE__-&gt;register_method(
			    method    =&gt; 'text_split',
			    api_name  =&gt; 'opensrf.simple-text.split'
			);</programlisting>
			</para></formalpara>
			<simpara>We simply return a reference to the list, and OpenSRF does the rest of the work
			for us to convert the data into the language-independent format that is then
			returned to the caller. As a caller of a given method, you must rely on the
			documentation used to register to determine the data structures - if the developer has
			added the appropriate documentation.</simpara>
		</simplesect>
		<simplesect id="_accepting_and_returning_evergreen_objects">
			<title>Accepting and returning Evergreen objects</title>
			<simpara>OpenSRF is agnostic about objects; its role is to pass JSON back and forth
			between OpenSRF clients and services, and it allows the specific clients and
			services to define their own semantics for the JSON structures. On top of that
			infrastructure, Evergreen offers the fieldmapper: an object-relational mapper
			that provides a complete definition of all objects, their properties, their
			relationships to other objects, the permissions required to create, read,
			update, or delete objects of that type, and the database table or view on which
			they are based.</simpara>
			<simpara>The Evergreen fieldmapper offers a great deal of convenience for working with
			complex system objects beyond the basic mapping of classes to database
			schemas. Although the result is passed over the wire as a JSON object
			containing the indicated fields, fieldmapper-aware clients then turn those
			JSON objects into native objects with setter / getter methods for each field.</simpara>
			<simpara>All of this metadata about Evergreen objects is defined in the
			fieldmapper configuration file (<literal>/openils/conf/fm_IDL.xml</literal>), and access to
			these classes is provided by the <literal>open-ils.cstore</literal>, <literal>open-ils.pcrud</literal>, and
			<literal>open-ils.reporter-store</literal> OpenSRF services which parse the fieldmapper
			configuration file and dynamically register OpenSRF methods for creating,
			reading, updating, and deleting all of the defined classes.</simpara>
			<formalpara><title>Example fieldmapper class definition for "Open User Summary"</title><para>
			<programlisting language="xml" linenumbering="unnumbered">&lt;class id="mous" controller="open-ils.cstore open-ils.pcrud"
			 oils_obj:fieldmapper="money::open_user_summary"
			 oils_persist:tablename="money.open_usr_summary"
			 reporter:label="Open User Summary"&gt;                                <co id="CO5-1"/>
			    &lt;fields oils_persist:primary="usr" oils_persist:sequence=""&gt; <co id="CO5-2"/> 
				&lt;field name="balance_owed" reporter:datatype="money" /&gt;  <co id="CO5-3"/> 
				&lt;field name="total_owed" reporter:datatype="money" /&gt;
				&lt;field name="total_paid" reporter:datatype="money" /&gt;
				&lt;field name="usr" reporter:datatype="link"/&gt;
			    &lt;/fields&gt;
			    &lt;links&gt;
				&lt;link field="usr" reltype="has_a" key="id" map="" class="au"/&gt;<co id="CO5-4"/> 
			    &lt;/links&gt;
			    &lt;permacrud xmlns="http://open-ils.org/spec/opensrf/IDL/permacrud/v1"&gt;<co id="CO5-5"/> 
				&lt;actions&gt;
				    &lt;retrieve permission="VIEW_USER"&gt;<co id="CO5-6"/> 
					&lt;context link="usr" field="home_ou"/&gt;<co id="CO5-7"/>
				    &lt;/retrieve&gt;
				&lt;/actions&gt;
			    &lt;/permacrud&gt;
			&lt;/class&gt;</programlisting>
			</para></formalpara>
			<calloutlist>
			<callout arearefs="CO5-1">
			<simpara>
			The <literal>&lt;class&gt;</literal> element defines the class:
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>id</literal> attribute defines the <emphasis>class hint</emphasis> that identifies the class both
			elsewhere in the fieldmapper configuration file, such as in the value of the
			<literal>field</literal> attribute of the <literal>&lt;link&gt;</literal> element, and in the JSON object itself when
			it is instantiated. For example, an "Open User Summary" JSON object would have
			the top level property of <literal>"__c":"mous"</literal>.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>controller</literal> attribute identifies the services that have direct access
			to this class. If <literal>open-ils.pcrud</literal> is not listed, for example, then there is
			no means to directly access members of this class through a public service.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>oils_obj:fieldmapper</literal> attribute defines the name of the Perl
			fieldmapper class that will be dynamically generated to provide setter and
			getter methods for instances of the class.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>oils_persist:tablename</literal> attribute identifies the schema name and table
			name of the database table that stores the data that represents the instances
			of this class. In this case, the schema is <literal>money</literal> and the table is
			<literal>open_usr_summary</literal>.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>reporter:label</literal> attribute defines a human-readable name for the class
			used in the reporting interface to identify the class. These names are defined
			in English in the fieldmapper configuration file; however, they are extracted
			so that they can be translated and served in the user&#8217;s language of choice.
			</simpara>
			</listitem>
			</itemizedlist>
			</callout>
			<callout arearefs="CO5-2">
			<simpara>
			The <literal>&lt;fields&gt;</literal> element lists all of the fields that belong to the object.
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>oils_persist:primary</literal> attribute identifies the field that acts as the
			primary key for the object; in this case, the field with the name <literal>usr</literal>.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>oils_persist:sequence</literal> attribute identifies the sequence object
			(if any) in this database provides values for new instances of this class. In
			this case, the primary key is defined by a field that is linked to a different
			table, so no sequence is used to populate these instances.
			</simpara>
			</listitem>
			</itemizedlist>
			</callout>
			<callout arearefs="CO5-3">
			<simpara>
			Each <literal>&lt;field&gt;</literal> element defines a single field with the following attributes:
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>name</literal> attribute identifies the column name of the field in the
			underlying database table as well as providing a name for the setter / getter
			method that can be invoked in the JSON or native version of the object.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>reporter:datatype</literal> attribute defines how the reporter should treat
			the contents of the field for the purposes of querying and display.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>reporter:label</literal> attribute can be used to provide a human-readable name
			for each field; without it, the reporter falls back to the value of the <literal>name</literal>
			attribute.
			</simpara>
			</listitem>
			</itemizedlist>
			</callout>
			<callout arearefs="CO5-4">
			<simpara>
			The <literal>&lt;links&gt;</literal> element contains a set of zero or more <literal>&lt;link&gt;</literal> elements,
			each of which defines a relationship between the class being described and
			another class.
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>field</literal> attribute identifies the field named in this class that links
			to the external class.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>reltype</literal> attribute identifies the kind of relationship between the
			classes; in the case of <literal>has_a</literal>, each value in the <literal>usr</literal> field is guaranteed
			to have a corresponding value in the external class.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>key</literal> attribute identifies the name of the field in the external
			class to which this field links.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The rarely-used <literal>map</literal> attribute identifies a second class to which
			the external class links; it enables this field to define a direct
			relationship to an external class with one degree of separation, to
			avoid having to retrieve all of the linked members of an intermediate
			class just to retrieve the instances from the actual desired target class.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>class</literal> attribute identifies the external class to which this field
			links.
			</simpara>
			</listitem>
			</itemizedlist>
			</callout>
			<callout arearefs="CO5-5">
			<simpara>
			The <literal>&lt;permacrud&gt;</literal> element defines the permissions that must have been
			granted to a user to operate on instances of this class.
			</simpara>
			</callout>
			<callout arearefs="CO5-6">
			<simpara>
			The <literal>&lt;retrieve&gt;</literal> element is one of four possible children of the
			<literal>&lt;actions&gt;</literal> element that define the permissions required for each action:
			create, retrieve, update, and delete.
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>permission</literal> attribute identifies the name of the permission that must
			have been granted to the user to perform the action.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>contextfield</literal> attribute, if it exists, defines the field in this class
			that identifies the library within the system for which the user must have
			prvileges to work. If a user has been granted a given permission, but has not been
			granted privileges to work at a given library, they can not perform the action
			at that library.
			</simpara>
			</listitem>
			</itemizedlist>
			</callout>
			<callout arearefs="CO5-7">
			<simpara>
			The rarely-used <literal>&lt;context&gt;</literal> element identifies a linked field (<literal>link</literal>
			attribute) in this class which links to an external class that holds the field
			(<literal>field</literal> attribute) that identifies the library within the system for which the
			user must have privileges to work.
			</simpara>
			</callout>
			</calloutlist>
			<simpara>When you retrieve an instance of a class, you can ask for the result to
			<emphasis>flesh</emphasis> some or all of the linked fields of that class, so that the linked
			instances are returned embedded directly in your requested instance. In that
			same request you can ask for the fleshed instances to in turn have their linked
			fields fleshed. By bundling all of this into a single request and result
			sequence, you can avoid the network overhead of requiring the client to request
			the base object, then request each linked object in turn.</simpara>
			<simpara>You can also iterate over a collection of instances and set the automatically
			generated <literal>isdeleted</literal>, <literal>isupdated</literal>, or <literal>isnew</literal> properties to indicate that
			the given instance has been deleted, updated, or created respectively.
			Evergreen can then act in batch mode over the collection to perform the
			requested actions on any of the instances that have been flagged for action.</simpara>
		</simplesect>
		<simplesect id="_returning_streaming_results">
			<title>Returning streaming results</title>
			<simpara>In the previous implementation of the <literal>opensrf.simple-text.split</literal> method, we
			returned a reference to the complete array of results. For small values being
			delivered over the network, this is perfectly acceptable, but for large sets of
			values this can pose a number of problems for the requesting client. Consider a
			service that returns a set of bibliographic records in response to a query like
			"all records edited in the past month"; if the underlying database is
			relatively active, that could result in thousands of records being returned as
			a single network request. The client would be forced to block until all of the
			results are returned, likely resulting in a significant delay, and depending on
			the implementation, correspondingly large amounts of memory might be consumed
			as all of the results are read from the network in a single block.</simpara>
			<simpara>OpenSRF offers a solution to this problem. If the method returns results that
			can be divided into separate meaningful units, you can register the OpenSRF
			method as a streaming method and enable the client to loop over the results one
			unit at a time until the method returns no further results. In addition to
			registering the method with the provided name, OpenSRF also registers an additional
			method with <literal>.atomic</literal> appended to the method name. The <literal>.atomic</literal> variant gathers
			all of the results into a single block to return to the client, giving the caller
			the ability to choose either streaming or atomic results from a single method
			definition.</simpara>
			<simpara>In the following example, the text splitting method has been reimplemented to
			support streaming; very few changes are required:</simpara>
			<formalpara><title>Text splitting method - streaming mode</title><para>
			<programlisting language="perl" linenumbering="unnumbered">sub text_split {
			    my $self = shift;
			    my $conn = shift;
			    my $text = shift;
			    my $delimiter = shift || ' ';

			    my @split_text = split $delimiter, $text;
			    foreach my $string (@split_text) { <co id="CO6-1"/>
				$conn-&gt;respond($string);
			    }
			    return undef;
			}

			__PACKAGE__-&gt;register_method(
			    method    =&gt; 'text_split',
			    api_name  =&gt; 'opensrf.simple-text.split',
			    stream    =&gt; 1<co id="CO6-2"/>
			);</programlisting>
			</para></formalpara>
			<calloutlist>
			<callout arearefs="CO6-1">
			<simpara>
			Rather than returning a reference to the array, a streaming method loops
			over the contents of the array and invokes the <literal>respond()</literal> method of the
			connection object on each element of the array.
			</simpara>
			</callout>
			<callout arearefs="CO6-2">
			<simpara>
			Registering the method as a streaming method instructs OpenSRF to also
			register an atomic variant (<literal>opensrf.simple-text.split.atomic</literal>).
			</simpara>
			</callout>
			</calloutlist>
		</simplesect>
		<simplesect id="_error_warning_info_debug">
			<title>Error! Warning! Info! Debug!</title>
			<simpara>As hard as it may be to believe, it is true: applications sometimes do not
			behave in the expected manner, particularly when they are still under
			development. The service language bindings for OpenSRF include integrated
			support for logging messages at the levels of ERROR, WARNING, INFO, DEBUG, and
			the extremely verbose INTERNAL to either a local file or to a syslogger
			service. The destination of the log files, and the level of verbosity to be
			logged, is set in the <literal>opensrf_core.xml</literal> configuration file. To add logging to
			our Perl example, we just have to add the <literal>OpenSRF::Utils::Logger</literal> package to our
			list of used Perl modules, then invoke the logger at the desired logging level.</simpara>
			<simpara>You can include many calls to the OpenSRF logger; only those that are higher
			than your configured logging level will actually hit the log. The following
			example exercises all of the available logging levels in OpenSRF:</simpara>
			<programlisting language="perl" linenumbering="unnumbered">use OpenSRF::Utils::Logger;
			my $logger = OpenSRF::Utils::Logger;
			# some code in some function
			{
			    $logger-&gt;error("Hmm, something bad DEFINITELY happened!");
			    $logger-&gt;warn("Hmm, something bad might have happened.");
			    $logger-&gt;info("Something happened.");
			    $logger-&gt;debug("Something happened; here are some more details.");
			    $logger-&gt;internal("Something happened; here are all the gory details.")
			}</programlisting>
			<simpara>If you call the mythical OpenSRF method containing the preceding OpenSRF logger
			statements on a system running at the default logging level of INFO, you will
			only see the INFO, WARN, and ERR messages, as follows:</simpara>
			<formalpara><title>Results of logging calls at the default level of INFO</title><para>
			<screen>[2010-03-17 22:27:30] opensrf.simple-text [ERR :5681:SimpleText.pm:277:] Hmm, something bad DEFINITELY happened!
			[2010-03-17 22:27:30] opensrf.simple-text [WARN:5681:SimpleText.pm:278:] Hmm, something bad might have happened.
			[2010-03-17 22:27:30] opensrf.simple-text [INFO:5681:SimpleText.pm:279:] Something happened.</screen>
			</para></formalpara>
			<simpara>If you then increase the the logging level to INTERNAL (5), the logs will
			contain much more information, as follows:</simpara>
			<formalpara><title>Results of logging calls at the default level of INTERNAL</title><para>
			<screen>[2010-03-17 22:48:11] opensrf.simple-text [ERR :5934:SimpleText.pm:277:] Hmm, something bad DEFINITELY happened!
			[2010-03-17 22:48:11] opensrf.simple-text [WARN:5934:SimpleText.pm:278:] Hmm, something bad might have happened.
			[2010-03-17 22:48:11] opensrf.simple-text [INFO:5934:SimpleText.pm:279:] Something happened.
			[2010-03-17 22:48:11] opensrf.simple-text [DEBG:5934:SimpleText.pm:280:] Something happened; here are some more details.
			[2010-03-17 22:48:11] opensrf.simple-text [INTL:5934:SimpleText.pm:281:] Something happened; here are all the gory details.
			[2010-03-17 22:48:11] opensrf.simple-text [ERR :5934:SimpleText.pm:283:] Resolver did not find a cache hit
			[2010-03-17 22:48:21] opensrf.simple-text [INTL:5934:Cache.pm:125:] Stored opensrf.simple-text.test_cache.masaa =&gt; "here" in memcached server
			[2010-03-17 22:48:21] opensrf.simple-text [DEBG:5934:Application.pm:579:] Coderef for [OpenSRF::Application::Demo::SimpleText::test_cache]...
			[2010-03-17 22:48:21] opensrf.simple-text [DEBG:5934:Application.pm:586:] A top level Request object is responding de nada
			[2010-03-17 22:48:21] opensrf.simple-text [DEBG:5934:Application.pm:190:] Method duration for [opensrf.simple-text.test_cache]:  10.005
			[2010-03-17 22:48:21] opensrf.simple-text [INTL:5934:AppSession.pm:780:] Calling queue_wait(0)
			[2010-03-17 22:48:21] opensrf.simple-text [INTL:5934:AppSession.pm:769:] Resending...0
			[2010-03-17 22:48:21] opensrf.simple-text [INTL:5934:AppSession.pm:450:] In send
			[2010-03-17 22:48:21] opensrf.simple-text [DEBG:5934:AppSession.pm:506:] AppSession sending RESULT to opensrf@private.localhost/... 
			[2010-03-17 22:48:21] opensrf.simple-text [DEBG:5934:AppSession.pm:506:] AppSession sending STATUS to opensrf@private.localhost/... 
			...</screen>
			</para></formalpara>
			<simpara>To see everything that is happening in OpenSRF, try leaving your logging level
			set to INTERNAL for a few minutes - just ensure that you have a lot of free disk
			space available if you have a moderately busy system!</simpara>
		</simplesect>
		<simplesect id="_caching_results_one_secret_of_scalability">
			<title>Caching results: one secret of scalability</title>
			<simpara>If you have ever used an application that depends on a remote Web service
			outside of your control&#8201;&#8212;&#8201;say, if you need to retrieve results from a
			microblogging service&#8201;&#8212;&#8201;you know the pain of latency and dependability (or the
			lack thereof). To improve the response time for OpenSRF services, you can take
			advantage of the support offered by the <literal>OpenSRF::Utils::Cache</literal> module for
			communicating with a local instance or cluster of <literal>memcache</literal> daemons to store
			and retrieve persistent values. The following example demonstrates caching
			by sleeping for 10 seconds the first time it receives a given cache key and
			cannot retrieve a corresponding value from the cache:</simpara>
			<formalpara><title>Simple caching OpenSRF service</title><para>
			<programlisting language="perl" linenumbering="unnumbered">use OpenSRF::Utils::Cache;<co id="CO7-1"/>
			sub test_cache {
			    my $self = shift;
			    my $conn = shift;
			    my $test_key = shift;
			    my $cache = OpenSRF::Utils::Cache-&gt;new('global'); <co id="CO7-2"/>
			    my $cache_key = "opensrf.simple-text.test_cache.$test_key"; <co id="CO7-3"/>
			    my $result = $cache-&gt;get_cache($cache_key) || undef; <co id="CO7-4"/>
			    if ($result) {
				$logger-&gt;info("Resolver found a cache hit");
				return $result;
			    }
			    sleep 10; <co id="CO7-5"/>
			    my $cache_timeout = 300; <co id="CO7-6"/>
			    $cache-&gt;put_cache($cache_key, "here", $cache_timeout); <co id="CO7-7"/>
			    return "There was no cache hit.";
			}</programlisting>
			</para></formalpara>
			<calloutlist>
			<callout arearefs="CO7-1">
			<simpara>
			The OpenSRF::Utils::Cache module provides access to the built-in caching
			support in OpenSRF.
			</simpara>
			</callout>
			<callout arearefs="CO7-2">
			<simpara>
			The constructor for the cache object accepts a single argument to define
			the cache type for the object. Each cache type can use a separate <literal>memcache</literal>
			server to keep the caches separated. Most Evergreen services use the <literal>global</literal>
			cache, while the <literal>anon</literal> cache is used for Web sessions.
			</simpara>
			</callout>
			<callout arearefs="CO7-3">
			<simpara>
			The cache key is simply a string that uniquely identifies the value you
			want to store or retrieve. This line creates a cache key based on the OpenSRF
			method name and request input value.
			</simpara>
			</callout>
			<callout arearefs="CO7-4">
			<simpara>
			The <literal>get_cache()</literal> method checks to see if the cache key already exists. If
			a matching key is found, the service immediately returns the stored value.
			</simpara>
			</callout>
			<callout arearefs="CO7-5">
			<simpara>
			If the cache key does not exist, the code sleeps for 10 seconds to
			simulate a call to a slow remote Web service or an intensive process.
			</simpara>
			</callout>
			<callout arearefs="CO7-6">
			<simpara>
			The <literal>$cache_timeout</literal> variable represents a value for the lifetime of the
			cache key in seconds.
			</simpara>
			</callout>
			<callout arearefs="CO7-7">
			<simpara>
			After the code retrieves its value (or, in the case of this example,
			finishes sleeping), it creates the cache entry by calling the <literal>put_cache()</literal>
			method. The method accepts three arguments: the cache key, the value to be
			stored ("here"), and the timeout value in seconds to ensure that we do not
			return stale data on subsequent calls.
			</simpara>
			</callout>
			</calloutlist>
		</simplesect>
		<simplesect id="_initializing_the_service_and_its_children_child_labour">
			<title>Initializing the service and its children: child labour</title>
			<simpara>When an OpenSRF service is started, it looks for a procedure called
			<literal>initialize()</literal> to set up any global variables shared by all of the children of
			the service. The <literal>initialize()</literal> procedure is typically used to retrieve
			configuration settings from the <literal>opensrf.xml</literal> file.</simpara>
			<simpara>An OpenSRF service spawns one or more children to actually do the work
			requested by callers of the service. For every child process an OpenSRF service
			spawns, the child process clones the parent environment and then each child
			process runs the <literal>child_init()</literal> process (if any) defined in the OpenSRF service
			to initialize any child-specific settings.</simpara>
			<simpara>When the OpenSRF service kills a child process, it invokes the <literal>child_exit()</literal>
			procedure (if any) to clean up any resources associated with the child process.
			Similarly, when the OpenSRF service is stopped, it calls the <literal>DESTROY()</literal>
			procedure to clean up any remaining resources.</simpara>
		</simplesect>
		<simplesect id="_retrieving_configuration_settings">
			<title>Retrieving configuration settings</title>
			<simpara>The settings for OpenSRF services are maintained in the <literal>opensrf.xml</literal> XML
			configuration file. The structure of the XML document consists of a root
			element <literal>&lt;opensrf&gt;</literal> containing two child elements:</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>&lt;default&gt;</literal> element contains an <literal>&lt;apps&gt;</literal> element describing all
			OpenSRF services running on this system&#8201;&#8212;&#8201;see <xref linkend="serviceRegistration"/> --, as
			well as any other arbitrary XML descriptions required for global configuration
			purposes. For example, Evergreen uses this section for email notification and
			inter-library patron privacy settings.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>&lt;hosts&gt;</literal> element contains one element per host that participates in
			this OpenSRF system. Each host element must include an <literal>&lt;activeapps&gt;</literal> element
			that lists all of the services to start on this host when the system starts
			up. Each host element can optionally override any of the default settings.
			</simpara>
			</listitem>
			</itemizedlist>
			<simpara>OpenSRF includes a service named <literal>opensrf.settings</literal> to provide distributed
			cached access to the configuration settings with a simple API:</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			<literal>opensrf.settings.default_config.get</literal> accepts zero arguments and returns
			the complete set of default settings as a JSON document.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			<literal>opensrf.settings.host_config.get</literal> accepts one argument (hostname) and
			returns the complete set of settings, as customized for that hostname, as a
			JSON document.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			<literal>opensrf.settings.xpath.get</literal> accepts one argument (an
			<ulink url="http://www.w3.org/TR/xpath/">XPath</ulink> expression) and returns the portion of
			the configuration file that matches the expression as a JSON document.
			</simpara>
			</listitem>
			</itemizedlist>
			<simpara>For example, to determine whether an Evergreen system uses the opt-in
			support for sharing patron information between libraries, you could either
			invoke the <literal>opensrf.settings.default_config.get</literal> method and parse the
			JSON document to determine the value, or invoke the <literal>opensrf.settings.xpath.get</literal>
			method with the XPath <literal>/opensrf/default/share/user/opt_in</literal> argument to
			retrieve the value directly.</simpara>
			<simpara>In practice, OpenSRF includes convenience libraries in all of its client
			language bindings to simplify access to configuration values. C offers
			osrfConfig.c, Perl offers <literal>OpenSRF::Utils::SettingsClient</literal>, Java offers
			<literal>org.opensrf.util.SettingsClient</literal>, and Python offers <literal>osrf.set</literal>. These
			libraries locally cache the configuration file to avoid network roundtrips for
			every request and enable the developer to request specific values without
			having to manually construct XPath expressions.</simpara>
		</simplesect>
	</section>
	<section id="_getting_under_the_covers_with_opensrf">
		<title>OpenSRF Communication Flows</title>
		<simpara>Now that you have seen that it truly is easy to create an OpenSRF service, we
		can take a look at what is going on under the covers to make all of this work
		for you.</simpara>
		<simplesect id="_get_on_the_messaging_bus_safely">
			<title>Get on the messaging bus - safely</title>
			<simpara>One of the core innovations of OpenSRF was to use the Extensible Messaging and
			Presence Protocol (XMPP, more colloquially known as Jabber) as the messaging
			bus that ties OpenSRF services together across servers. XMPP is an "XML
			protocol for near-real-time messaging, presence, and request-response services"
			(<ulink url="http://www.ietf.org/rfc/rfc3920.txt">http://www.ietf.org/rfc/rfc3920.txt</ulink>) that OpenSRF relies on to handle most of
			the complexity of networked communications.  OpenSRF requres an XMPP server
			that supports multiple domains such as <ulink url="http://www.ejabberd.im/">ejabberd</ulink>.
			Multiple domain support means that a single server can support XMPP virtual
			hosts with separate sets of users and access privileges per domain. By
			routing communications through separate public and private XMPP domains,
			OpenSRF services gain an additional layer of security.</simpara>
			<simpara>The <ulink url="http://evergreen-ils.org/dokuwiki/doku.php?id=opensrf:1.2:install">OpenSRF
			installation documentation</ulink> instructs you to create two separate hostnames
			(<literal>private.localhost</literal> and <literal>public.localhost</literal>) to use as XMPP domains.  OpenSRF
			can control access to its services based on the domain of the client and
			whether a given service allows access from clients on the public domain.  When
			you start OpenSRF, the first XMPP clients that connect to the XMPP server are
			the OpenSRF public and private <emphasis>routers</emphasis>. OpenSRF routers maintain a list of
			available services and connect clients to available services. When an OpenSRF
			service starts, it establishes a connection to the XMPP server and registers
			itself with the private router. The OpenSRF configuration contains a list of
			public OpenSRF services, each of which must also register with the public
			router.</simpara>
		</simplesect>
		<simplesect id="_opensrf_communication_flows_over_xmpp">
			<title>OpenSRF communication flows over XMPP</title>
			<simpara>In a minimal OpenSRF deployment, two XMPP users named "router" connect to the
			XMPP server, with one connected to the private XMPP domain and one connected to
			the public XMPP domain. Similarly, two XMPP users named "opensrf" connect to
			the XMPP server via the private and public XMPP domains. When an OpenSRF
			service is started, it uses the "opensrf" XMPP user to advertise its
			availability with the corresponding router on that XMPP domain; the XMPP server
			automatically assigns a Jabber ID (<emphasis>JID</emphasis>) based on the client hostname to each
			service&#8217;s listener process and each connected drone process waiting to carry
			out requests. When an OpenSRF router receives a request to invoke a method on a
			given service, it connects the requester to the next available listener in the
			list of registered listeners for that service.</simpara>
			<simpara>Services and clients connect to the XMPP server using a single set of XMPP
			client credentials (for example, <literal>opensrf@private.localhost</literal>), but use XMPP
			resource identifiers to differentiate themselves in the JID for each
			connection. For example, the JID for a copy of the <literal>opensrf.simple-text</literal>
			service with process ID <literal>6285</literal> that has connected to the <literal>private.localhost</literal>
			domain using the <literal>opensrf</literal> XMPP client credentials could be
			<literal>opensrf@private.localhost/opensrf.simple-text_drone_at_localhost_6285</literal>.  By
			convention, the user name for OpenSRF clients is <literal>opensrf</literal>, and the user name
			for OpenSRF routers is <literal>router</literal>, so the XMPP server for OpenSRF will have four
			separate users registered:
			  * <literal>opensrf@private.localhost</literal> is an OpenSRF client that connects with these
			credentials and which can access any OpenSRF service.
			  * <literal>opensrf@public.localhost</literal> is an OpenSRF client that connects with these
			credentials and which can only access OpenSRF services that have registered
			with the public router.
			  * <literal>router@private.localhost</literal> is the private OpenSRF router with which all
			services register.
			  * <literal>router@public.localhost</literal> is the public OpenSRF router with which only
			services that must be publicly accessible register.</simpara>
			<simpara>All OpenSRF services automatically register themselves with the private XMPP
			domain, but only those services that register themselves with the public XMPP
			domain can be invoked from public OpenSRF clients.  The OpenSRF client and
			router user names, passwords, and domain names, along with the list of services
			that should be public, are contained in the <literal>opensrf_core.xml</literal> configuration
			file.</simpara>
		</simplesect>
		<simplesect id="OpenSRFOverHTTP">
			<title>OpenSRF communication flows over HTTP</title>
			<simpara>In some contexts, access to a full XMPP client is not a practical option. For
			example, while XMPP clients have been implemented in JavaScript, you might
			be concerned about browser compatibility and processing overhead - or you might
			want to issue OpenSRF requests from the command line with <literal>curl</literal>. Fortunately,
			any OpenSRF service registered with the public router is accessible via the
			OpenSRF HTTP Translator. The OpenSRF HTTP Translator implements the
			<ulink url="http://www.open-ils.org/dokuwiki/doku.php?id=opensrf_over_http">OpenSRF-over-HTTP
			proposed specification</ulink> as an Apache module that translates HTTP requests into
			OpenSRF requests and returns OpenSRF results as HTTP results to the initiating
			HTTP client.</simpara>
			<formalpara><title>Issuing an HTTP POST request to an OpenSRF method via the OpenSRF HTTP Translator</title><para>
			<programlisting language="bash" linenumbering="unnumbered"># curl request broken up over multiple lines for legibility
			curl -H "X-OpenSRF-service: opensrf.simple-text"<co id="CO8-1"/>
			    --data 'osrf-msg=[  \<co id="CO8-2"/>
				{"__c":"osrfMessage","__p":{"threadTrace":0,"locale":"en-CA", <co id="CO8-3"/>
				    "type":"REQUEST","payload": {"__c":"osrfMethod","__p": 
					{"method":"opensrf.simple-text.reverse","params":["foobar"]}   
				    }}                                                                  
				}]'                                                                    
			http://localhost/osrf-http-translator <co id="CO8-4"/></programlisting>
			</para></formalpara>
			<calloutlist>
			<callout arearefs="CO8-1">
			<simpara>
			The <literal>X-OpenSRF-service</literal> header identifies the OpenSRF service of interest.
			</simpara>
			</callout>
			<callout arearefs="CO8-2">
			<simpara>
			The POST request consists of a single parameter, the <literal>osrf-msg</literal> value,
			which contains a JSON array.
			</simpara>
			</callout>
			<callout arearefs="CO8-3">
			<simpara>
			The first object is an OpenSRF message (<literal>"__c":"osrfMessage"</literal>) with a set of
			parameters (<literal>"__p":{}</literal>).
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The identifier for the request (<literal>"threadTrace":0</literal>); this value is echoed
			back in the result.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The message type (<literal>"type":"REQUEST"</literal>).
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The locale for the message; if the OpenSRF method is locale-sensitive, it
			can check the locale for each OpenSRF request and return different information
			depending on the locale.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The payload of the message (<literal>"payload":{}</literal>) containing the OpenSRF method
			request (<literal>"__c":"osrfMethod"</literal>) and its parameters (<literal>"__p:"{}</literal>).
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The method name for the request (<literal>"method":"opensrf.simple-text.reverse"</literal>).
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			A set of JSON parameters to pass to the method (<literal>"params":["foobar"]</literal>); in
			this case, a single string <literal>"foobar"</literal>.
			</simpara>
			</listitem>
			</itemizedlist>
			</listitem>
			</itemizedlist>
			</callout>
			<callout arearefs="CO8-4">
			<simpara>
			The URL on which the OpenSRF HTTP translator is listening,
			<literal>/osrf-http-translator</literal> is the default location in the Apache example
			configuration files shipped with the OpenSRF source, but this is configurable.
			</simpara>
			</callout>
			</calloutlist>
			<formalpara><title>Results from an HTTP POST request to an OpenSRF method via the OpenSRF HTTP Translator</title><para>
			<programlisting language="bash" linenumbering="unnumbered"># HTTP response broken up over multiple lines for legibility
			[{"__c":"osrfMessage","__p":   <co id="CO9-1"/>
			    {"threadTrace":0, "payload": <co id="CO9-2"/>
				{"__c":"osrfResult","__p": <co id="CO9-3"/>
				    {"status":"OK","content":"raboof","statusCode":200} <co id="CO9-4"/>
				},"type":"RESULT","locale":"en-CA" <co id="CO9-5"/>
			    }
			},
			{"__c":"osrfMessage","__p":   <co id="CO9-6"/>
			    {"threadTrace":0,"payload":  <co id="CO9-7"/>
				{"__c":"osrfConnectStatus","__p": <co id="CO9-8"/>
				    {"status":"Request Complete","statusCode":205}<co id="CO9-9"/>
				},"type":"STATUS","locale":"en-CA"  <co id="CO9-10"/>
			    }
			}]</programlisting>
			</para></formalpara>
			<calloutlist>
			<callout arearefs="CO9-1">
			<simpara>
			The OpenSRF HTTP Translator returns an array of JSON objects in its
			response. Each object in the response is an OpenSRF message
			(<literal>"__c":"osrfMessage"</literal>) with a collection of response parameters (<literal>"__p":</literal>).
			</simpara>
			</callout>
			<callout arearefs="CO9-2">
			<simpara>
			The OpenSRF message identifier (<literal>"threadTrace":0</literal>) confirms that this
			message is in response to the request matching the same identifier.
			</simpara>
			</callout>
			<callout arearefs="CO9-3">
			<simpara>
			The message includes a payload JSON object (<literal>"payload":</literal>) with an OpenSRF
			result for the request (<literal>"__c":"osrfResult"</literal>).
			</simpara>
			</callout>
			<callout arearefs="CO9-4">
			<simpara>
			The result includes a status indicator string (<literal>"status":"OK"</literal>), the content
			of the result response - in this case, a single string "raboof"
			(<literal>"content":"raboof"</literal>) - and an integer status code for the request
			(<literal>"statusCode":200</literal>).
			</simpara>
			</callout>
			<callout arearefs="CO9-5">
			<simpara>
			The message also includes the message type (<literal>"type":"RESULT"</literal>) and the
			message locale (<literal>"locale":"en-CA"</literal>).
			</simpara>
			</callout>
			<callout arearefs="CO9-6">
			<simpara>
			The second message in the set of results from the response.
			</simpara>
			</callout>
			<callout arearefs="CO9-7">
			<simpara>
			Again, the message identifier confirms that this message is in response to
			a particular request.
			</simpara>
			</callout>
			<callout arearefs="CO9-8">
			<simpara>
			The payload of the message denotes that this message is an
			OpenSRF connection status message (<literal>"__c":"osrfConnectStatus"</literal>), with some
			information about the particular OpenSRF connection that was used for this
			request.
			</simpara>
			</callout>
			<callout arearefs="CO9-9">
			<simpara>
			The response parameters for an OpenSRF connection status message include a
			verbose status (<literal>"status":"Request Complete"</literal>) and an integer status code for
			the connection status (`"statusCode":205).
			</simpara>
			</callout>
			<callout arearefs="CO9-10">
			<simpara>
			The message also includes the message type (<literal>"type":"RESULT"</literal>) and the
			message locale (<literal>"locale":"en-CA"</literal>).
			</simpara>
			</callout>
			</calloutlist>
			<tip><simpara>Before adding a new public OpenSRF service, ensure that it does
			not introduce privilege escalation or unchecked access to data. For example,
			the Evergreen <literal>open-ils.cstore</literal> private service is an object-relational mapper
			that provides read and write access to the entire Evergreen database, so it
			would be catastrophic to expose that service publicly. In comparison, the
			Evergreen <literal>open-ils.pcrud</literal> public service offers the same functionality as
			<literal>open-ils.cstore</literal> to any connected HTTP client or OpenSRF client, but the
			additional authentication and authorization layer in <literal>open-ils.pcrud</literal> prevents
			unchecked access to Evergreen&#8217;s data.</simpara></tip>
		</simplesect>
		<simplesect id="_stateless_and_stateful_connections">
			<title>Stateless and stateful connections</title>
			<simpara>OpenSRF supports both <emphasis>stateless</emphasis> and <emphasis>stateful</emphasis> connections.  When an OpenSRF
			client issues a <literal>REQUEST</literal> message in a <emphasis>stateless</emphasis> connection, the router
			forwards the request to the next available service and the service returns the
			result directly to the client.</simpara>
			<formalpara><title>REQUEST flow in a stateless connection</title><para><inlinemediaobject>
			  <imageobject>
			  <imagedata fileref="REQUEST.png"/>
			  </imageobject>
			  <textobject><phrase>REQUEST flow in a stateless connection</phrase></textobject>
			</inlinemediaobject></para></formalpara>
			<simpara>When an OpenSRF client issues a <literal>CONNECT</literal> message to create a <emphasis>stateful</emphasis> conection, the
			router returns the Jabber ID of the next available service to the client so
			that the client can issue one or more <literal>REQUEST</literal> message directly to that
			particular service and the service will return corresponding <literal>RESULT</literal> messages
			directly to the client. Until the client issues a <literal>DISCONNECT</literal> message, that
			particular service is only available to the requesting client. Stateful connections
			are useful for clients that need to make many requests from a particular service,
			as it avoids the intermediary step of contacting the router for each request, as
			well as for operations that require a controlled sequence of commands, such as a
			set of database INSERT, UPDATE, and DELETE statements within a transaction.</simpara>
			<formalpara><title>CONNECT, REQUEST, and DISCONNECT flow in a stateful connection</title><para><inlinemediaobject>
			  <imageobject>
			  <imagedata fileref="CONNECT.png"/>
			  </imageobject>
			  <textobject><phrase>CONNECT</phrase></textobject>
			</inlinemediaobject></para></formalpara>
		</simplesect>
		<simplesect id="_message_body_format">
			<title>Message body format</title>
			<simpara>OpenSRF was an early adopter of JavaScript Object Notation (JSON). While XMPP
			is an XML protocol, the Evergreen developers recognized that the compactness of
			the JSON format offered a significant reduction in bandwidth for the volume of
			messages that would be generated in an application of that size. In addition,
			the ability of languages such as JavaScript, Perl, and Python to generate
			native objects with minimal parsing offered an attractive advantage over
			invoking an XML parser for every message. Instead, the body of the XMPP message
			is a simple JSON structure. For a simple request, like the following example
			that simply reverses a string, it looks like a significant overhead: but we get
			the advantages of locale support and tracing the request from the requester
			through the listener and responder (drone).</simpara>
			<formalpara><title>A request for opensrf.simple-text.reverse("foobar"):</title><para>
			<programlisting language="xml" linenumbering="unnumbered">&lt;message from='router@private.localhost/opensrf.simple-text'
			  to='opensrf@private.localhost/opensrf.simple-text_listener_at_localhost_6275'
			  router_from='opensrf@private.localhost/_karmic_126678.3719_6288'
			  router_to='' router_class='' router_command='' osrf_xid=''
			&gt;
			  &lt;thread&gt;1266781414.366573.12667814146288&lt;/thread&gt;
			  &lt;body&gt;
			[
			  {"__c":"osrfMessage","__p":
			    {"threadTrace":"1","locale":"en-US","type":"REQUEST","payload":
			      {"__c":"osrfMethod","__p":
				{"method":"opensrf.simple-text.reverse","params":["foobar"]}
			      }
			    }
			  }
			]
			  &lt;/body&gt;
			&lt;/message&gt;</programlisting>
			</para></formalpara>
			<formalpara><title>A response from opensrf.simple-text.reverse("foobar")</title><para>
			<programlisting language="xml" linenumbering="unnumbered">&lt;message from='opensrf@private.localhost/opensrf.simple-text_drone_at_localhost_6285'
			  to='opensrf@private.localhost/_karmic_126678.3719_6288'
			  router_command='' router_class='' osrf_xid=''
			&gt;
			  &lt;thread&gt;1266781414.366573.12667814146288&lt;/thread&gt;
			  &lt;body&gt;
			[
			  {"__c":"osrfMessage","__p":
			    {"threadTrace":"1","payload":
			      {"__c":"osrfResult","__p":
				{"status":"OK","content":"raboof","statusCode":200}
			      } ,"type":"RESULT","locale":"en-US"}
			  },
			  {"__c":"osrfMessage","__p":
			    {"threadTrace":"1","payload":
			      {"__c":"osrfConnectStatus","__p":
				{"status":"Request Complete","statusCode":205}
			      },"type":"STATUS","locale":"en-US"}
			  }
			]
			  &lt;/body&gt;
			&lt;/message&gt;</programlisting>
			</para></formalpara>
			<simpara>The content of the <literal>&lt;body&gt;</literal> element of the OpenSRF request and result should
			look familiar; they match the structure of the <link linkend="OpenSRFOverHTTP">OpenSRF over HTTP examples</link> that we previously dissected.</simpara>
		</simplesect>
		<simplesect id="_registering_opensrf_methods_in_depth">
			<title>Registering OpenSRF methods in depth</title>
			<simpara>Let&#8217;s explore the call to <literal>__PACKAGE__-&gt;register_method()</literal>; most of the members
			of the hash are optional, and for the sake of brevity we omitted them in the
			previous example. As we have seen in the results of the <link linkend="opensrfIntrospection">introspection call</link>, a
			verbose registration method call is recommended to better enable the internal
			documentation. Here is the complete set of members that you should pass to
			<literal>__PACKAGE__-&gt;register_method()</literal>:</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>method</literal> member specifies the name of the procedure in this module that is being registered as an OpenSRF method.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>api_name</literal> member specifies the invocable name of the OpenSRF method; by convention, the OpenSRF service name is used as the prefix.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The optional <literal>api_level</literal> member can be used for versioning the methods to allow the use of a deprecated API, but in practical use is always 1.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The optional <literal>argc</literal> member specifies the minimal number of arguments that the method expects.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The optional <literal>stream</literal> member, if set to any value, specifies that the method supports returning multiple values from a single call to subsequent requests. OpenSRF automatically creates a corresponding method with ".atomic" appended to its name that returns the complete set of results in a single request. Streaming methods are useful if you are returning hundreds of records and want to act on the results as they return.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The optional <literal>signature</literal> member is a hash that describes the method&#8217;s purpose, arguments, and return value.
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>desc</literal> member of the <literal>signature</literal> hash describes the method&#8217;s purpose.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>params</literal> member of the <literal>signature</literal> hash is an array of hashes in which each array element describes the corresponding method argument in order.
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>name</literal> member of the argument hash specifies the name of the argument.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>desc</literal> member of the argument hash describes the argument&#8217;s purpose.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>type</literal> member of the argument hash specifies the data type of the argument: for example, string, integer, boolean, number, array, or hash.
			</simpara>
			</listitem>
			</itemizedlist>
			</listitem>
			<listitem>
			<simpara>
			The <literal>return</literal> member of the <literal>signature</literal> hash is a hash that describes the return value of the method.
			</simpara>
			<itemizedlist>
			<listitem>
			<simpara>
			The <literal>desc</literal> member of the <literal>return</literal> hash describes the return value.
			</simpara>
			</listitem>
			<listitem>
			<simpara>
			The <literal>type</literal> member of the <literal>return</literal> hash specifies the data type of the return value: for example, string, integer, boolean, number, array, or hash.
			</simpara>
			</listitem>
			</itemizedlist>
			</listitem>
			</itemizedlist>
			</listitem>
			</itemizedlist>
		</simplesect>
	</section>
	<section id="_evergreen_specific_opensrf_services">
		<title>Evergreen-specific OpenSRF services</title>
		<simpara>Evergreen is currently the primary showcase for the use of OpenSRF as an
		application architecture. Evergreen 1.6.1 includes the following
		set of OpenSRF services:</simpara>
		<itemizedlist>
		<listitem>
		<simpara>
		The <literal>open-ils.actor</literal> service supports common tasks for working with user
		     accounts and libraries.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.auth</literal> service supports authentication of Evergreen users.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.booking</literal> service supports the management of reservations
		    for bookable items.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.cat</literal> service supports common cataloging tasks, such as
		     creating, modifying, and merging bibliographic and authority records.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.circ</literal> service supports circulation tasks such as checking
		    out items and calculating due dates.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.collections</literal> service supports tasks that assist collections
		    agencies in contacting users with outstanding fines above a certain
		    threshold.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.cstore</literal> private service supports unrestricted access to
		    Evergreen fieldmapper objects.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.ingest</literal> private service supports tasks for importing
		    data such as bibliographic and authority records.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.pcrud</literal> service supports permission-based access to Evergreen
		    fieldmapper objects.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.penalty</literal> penalty service supports the calculation of
		    penalties for users, such as being blocked from further borrowing, for
		    conditions such as having too many items checked out or too many unpaid
		    fines.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.reporter</literal> service supports the creation and scheduling of
		    reports.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.reporter-store</literal> private service supports access to Evergreen
		    fieldmapper objects for the reporting service.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.search</literal> service supports searching across bibliographic
		    records, authority records, serial records, Z39.50 sources, and ZIP codes.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.storage</literal> private service supports a deprecated method of
		    providing access to Evergreen fieldmapper objects. Implemented in Perl,
		    this service has largely been replaced by the much faster C-based
		    <literal>open-ils.cstore</literal> service.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.supercat</literal> service supports transforms of MARC records into
		    other formats, such as MODS, as well as providing Atom and RSS feeds and
		    SRU access.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.trigger</literal> private service supports event-based triggers for
		    actions such as overdue and holds available notification emails.
		</simpara>
		</listitem>
		<listitem>
		<simpara>
		The <literal>open-ils.vandelay</literal> service supports the import and export of batches of
		    bibliographic and authority records.
		</simpara>
		</listitem>
		</itemizedlist>
		<simpara>Of some interest is that the <literal>open-ils.reporter-store</literal> and <literal>open-ils.cstore</literal>
		services have identical implementations. Surfacing them as separate services
		enables a deployer of Evergreen to ensure that the reporting service does not
		interfere with the performance-critical <literal>open-ils.cstore</literal> service. One can also
		direct the reporting service to a read-only database replica to, again, avoid
		interference with <literal>open-ils.cstore</literal> which must write to the master database.</simpara>
		<simpara>There are only a few significant services that are not built on OpenSRF in
		Evergreen 1.6.0, such as the SIP and Z39.50 servers. These services implement
		different protocols and build on existing daemon architectures (Simple2ZOOM
		for Z39.50), but still rely on the other OpenSRF services to provide access
		to the Evergreen data. The non-OpenSRF services are reasonably self-contained
		and can be deployed on different servers to deliver the same sort of deployment
		flexibility as OpenSRF services, but have the disadvantage of not being
		integrated into the same configuration and control infrastructure as the
		OpenSRF services.</simpara>
	</section>
</chapter>
